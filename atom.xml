<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RockSpeechCoder</title>
  
  <subtitle>RockSpeechCoder</subtitle>
  <link href="https://rockspeechcoder.github.io/atom.xml" rel="self"/>
  
  <link href="https://rockspeechcoder.github.io/"/>
  <updated>2022-10-13T15:05:14.871Z</updated>
  <id>https://rockspeechcoder.github.io/</id>
  
  <author>
    <name>Yangzk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="https://rockspeechcoder.github.io/2022/07/22/shu-ju-jie-gou-he-suan-fa/"/>
    <id>https://rockspeechcoder.github.io/2022/07/22/shu-ju-jie-gou-he-suan-fa/</id>
    <published>2022-07-22T11:26:07.000Z</published>
    <updated>2022-10-13T15:05:14.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><ul><li>常数操作：一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。</li><li>时间复杂度：一个算法流程中，常数操作数量的一个指标，O</li><li>表达式中只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，name时间复杂度为O(f(N))。</li><li>常数项时间：评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，叫做常数项时间</li><li>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3)(立方阶) &lt; O(2^n) (指数阶)</li></ul><img src="/2022/07/22/shu-ju-jie-gou-he-suan-fa/image-1.png" class=""><h2 id="2-对数器"><a href="#2-对数器" class="headerlink" title="2. 对数器"></a>2. 对数器</h2><ol><li>有一个你想要测的方法a </li><li>实现复杂度不好但是容易实现的方法b </li><li>实现一个随机样本产生器 </li><li>把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。 </li><li>如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b </li><li>当样本数量很多时比对测试依然正确，可以确定方法a已经正确</li></ol><h2 id="3-比较器"><a href="#3-比较器" class="headerlink" title="3. 比较器"></a>3. 比较器</h2><p>实现Comparator接口，重写compare方法，实现复杂的比价策略</p><h2 id="4-递归"><a href="#4-递归" class="headerlink" title="4. 递归"></a>4. 递归</h2><ol><li><p>master公式</p> <pre class="line-numbers language-none"><code class="language-none">T(N) &#x3D; a*T(N&#x2F;b) + O(N^d)&#x2F;&#x2F; N:母规模,a:次数,b:子规模<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))</li><li>log(b,a) = d -&gt; 复杂度为O(N^d * logN)</li><li> log(b,a) &lt; d -&gt; 复杂度为O(N^d)</li></ul></li></ol><h2 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h2><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h3><ul><li><p>特点</p><ul><li><p>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</p></li><li><p>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</p></li><li><p>一棵树不包含回路。</p></li></ul></li><li><p>概念</p><ul><li><strong>节点</strong> ：树中的每个元素都可以统称为节点。</li><li><strong>根节点</strong> ：顶层节点或者说没有父节点的节点。</li><li><strong>父节点</strong> ：若一个节点含有子节点，则这个节点称为其子节点的父节点。</li><li><strong>子节点</strong> ：一个节点含有的子树的根节点称为该节点的子节点。</li><li><strong>兄弟节点</strong> ：具有相同父节点的节点互称为兄弟节点。</li><li><strong>叶子节点</strong> ：没有子节点的节点。</li><li><strong>节点的高度</strong> ：该节点到叶子节点的最长路径所包含的边数。</li><li><strong>节点的深度</strong> ：根节点到该节点的路径所包含的边数</li><li><strong>节点的层数</strong> ：节点的深度+1。</li><li><strong>树的高度</strong> ：根节点的高度。</li></ul></li><li><p>二叉树</p><p><strong>二叉树</strong>（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p><p><strong>二叉树</strong> 的分支通常被称作“<strong>左子树</strong>”或“<strong>右子树</strong>”。并且，<strong>二叉树</strong> 的分支具有左右次序，不能随意颠倒。</p><p><strong>二叉树</strong> 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^(k+1)-1</code> 个节点（满二叉树的情况），至少有 2^(k) 个节点</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Node&lt;V&gt;&#123;    V value;    Node left;    Node right;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>满二叉树</p><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 <strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。满二叉树一定是完全二叉树。</p><ul><li>判断方法：求深度k，求节点个数，满足(2^k) -1</li></ul></li><li><p>完全二叉树</p><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <strong>完全二叉树</strong> 。</p><p><strong>父结点和子节点的序号有着对应关系。</strong></p><ul><li>判断方法1：层级遍历，如果出现有右子节点无左子节点的情况，返回false；当遇到第一个左右子节点不全的节点，剩余节点必须是叶子结点，否则false</li></ul></li><li><p>平衡二叉树</p><ol><li>可以是一棵空树</li><li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li></ol></li><li><p>搜索二叉树</p><p>每个节点的左子节点都比它小，右子节点都比它大。经典搜索二叉树一般认为没有重复值。</p><p>中序遍历可以得出升序的排序</p><ul><li>判断方法1：中序遍历后看排序是否升序</li><li>判断方法2：递归每一个子树是否满足搜索二叉树</li></ul></li></ul><h3 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. 存储</h3><ol><li><p>链式存储</p><p>二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。引用对象。</p></li><li><p>顺序存储</p><p>利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。</p></li></ol><h3 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3. 遍历"></a>3. 遍历</h3><ul><li><p>先序遍历</p><p>二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void preOrder(TreeNode root)&#123;if(root &#x3D;&#x3D; null)&#123;return;&#125;system.out.println(root.data);preOrder(root.left);preOrder(root.right);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>中序遍历</p><p>二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void inOrder(TreeNode root)&#123;if(root &#x3D;&#x3D; null)&#123;return;&#125;inOrder(root.left);system.out.println(root.data);inOrder(root.right);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>后序遍历</p><p>二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void postOrder(TreeNode root)&#123;if(root &#x3D;&#x3D; null)&#123;return;&#125;postOrder(root.left);postOrder(root.right);system.out.println(root.data);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h3><ul><li><p><strong>红黑树特点</strong> :</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol></li><li><p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p></li><li><p><strong>为什么要用红黑树？</strong> 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></li></ul><h2 id="6-堆"><a href="#6-堆" class="headerlink" title="6. 堆"></a>6. 堆</h2><h3 id="1-描述-1"><a href="#1-描述-1" class="headerlink" title="1. 描述"></a>1. 描述</h3><p>​    堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。任意一个节点的值都大于等于（或小于等于）所有子节点的值。最大堆：每个节点都比子树中所有节点大。最小堆：每个节点都比子树中所有节点小。</p><h3 id="2-用途"><a href="#2-用途" class="headerlink" title="2. 用途"></a>2. 用途</h3><p>   存在多次获取最大值或者最小值，多次插入或删除数据。</p><h3 id="3-操作"><a href="#3-操作" class="headerlink" title="3. 操作"></a>3. 操作</h3><ul><li><strong>插入元素</strong> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li><li><strong>删除堆顶元素</strong> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li></ul><h2 id="7-哈希表"><a href="#7-哈希表" class="headerlink" title="7. 哈希表"></a>7. 哈希表</h2><ol><li>哈希表在使用层面上可以理解为一种集合结构 </li><li>如果只有key，没有伴随数据value，可以使用HashSet结构</li><li>如果既有key，又有伴随数据value，可以使用HashMap结构</li><li>有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事 </li><li>使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大 </li><li>放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小 </li><li>放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小</li></ol><h2 id="8-有序表"><a href="#8-有序表" class="headerlink" title="8. 有序表"></a>8. 有序表</h2><ol><li>有序表在使用层面上可以理解为一种集合结构</li><li>如果只有key，没有伴随数据value，可以使用TreeSet结构</li><li>如果既有key，又有伴随数据value，可以使用TreeMap结构</li><li>有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事</li><li>有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织</li><li>红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同 </li><li>放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小</li><li>放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小</li><li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度</li></ol><h2 id="9-单链表"><a href="#9-单链表" class="headerlink" title="9. 单链表"></a>9. 单链表</h2><p>​    <strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p><p>​    链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p><p>​    使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p><p>单链表和双链表结构只需要给定一个头部节点head，就可以找到剩下的所有的节点。</p><ul><li><p>单链表的节点结构</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class Node&#123;     V value;     Node next; &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​        由以上结构的节点依次连接起来所形成的链叫单链表结构。 </p><ul><li><p>双链表的节点结构 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class Node&#123; V value; Node next; Node last; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由以上结构的节点依次连接起来所形成的链叫双链表结构。 </p></li></ul><h2 id="10-排序"><a href="#10-排序" class="headerlink" title="10. 排序"></a>10. 排序</h2><p>   同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。 </p><ul><li>不具备稳定性的排序： 选择排序、快速排序、堆排序 </li><li>具备稳定性的排序： 冒泡排序、插入排序、归并排序、一切桶排序思想下的排序</li><li>目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。</li></ul><h2 id="11-图"><a href="#11-图" class="headerlink" title="11. 图"></a>11. 图</h2><ol><li><p>描述</p><p>图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：**G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p></li><li><p>概念</p><ul><li><p>顶点</p><p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）</p><p>对应到好友关系图，每一个用户就代表一个顶点。</p></li><li><p>边</p><p>顶点之间的关系用边表示。</p><p>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。</p></li><li><p>度</p><p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。</p><p>对应到好友关系图，度就代表了某个人的好友数量。</p></li><li><p>无向图和有向图</p><p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。</p><p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。</p></li><li><p>无权图和带权图</p><p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。</p><p>对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p></li></ul></li><li><p>图的存储</p><ul><li><p>邻接矩阵存储</p><p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。</p><p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 <code>A[i][j]=n</code> 。</p><p>在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，<code>A[i][j]</code>=1，当顶点i和顶点j没有关系时，<code>A[i][j]</code>=0。</p><p><strong>无向图的邻接矩阵是一个对称矩阵</strong></p><p>邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，</p></li><li><p>邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 <strong>邻接表</strong>。</p><ul><li>在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。</li><li>在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。</li></ul></li></ul></li><li><p>图的遍历</p><ul><li><p>图的宽度优先遍历</p><ol><li>利用队列实现</li><li>从源节点开始依次按照宽度进队列，然后弹出</li><li>每弹出一个点，把该节点所有没有进过队列的邻接点放入队列</li><li>直到队列变空</li></ol></li><li><p>广度优先遍历</p><ol><li>利用栈实现</li><li>从源节点开始把节点按照深度放入栈，然后弹出</li><li>每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈</li><li>直到栈变空</li></ol></li><li><p>拓扑排序</p><p>适用范围：要求有向图，且有入度为0的节点，且没有环</p><ol><li>找到入度为0的节点，保存到只存储入度为0的队列中</li><li>添加到结果排序集</li><li>找到此节点指向的其他节点，如果减掉此指向的入度为0，添加到队列和结果集中，循环此步骤</li></ol></li><li><p>kruskal算法（无向图生成最小生成树）</p><ol><li>遍历每个节点，生成对应只有自己的集合</li><li>将图的所有边根据权重升序排列</li><li>判断每条边的始末节点是否在同一个集合中，如果不在同一个集合中，合并两个集合，直到集合包含所有节点</li></ol></li><li><p>Prime算法</p><ol><li>从任意节点检查，将该节点的所有边选出权重最小的边</li><li>检查该边的to节点是否已检查，如果没检查则将该节点的所有边选出权重最小的边</li><li>重复上述步骤，直到所有节点都检查过</li></ol></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构和算法&quot;&gt;&lt;a href=&quot;#数据结构和算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构和算法&quot;&gt;&lt;/a&gt;数据结构和算法&lt;/h1&gt;&lt;h2 id=&quot;1-时间复杂度&quot;&gt;&lt;a href=&quot;#1-时间复杂度&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>线性数据结构 :数组、链表、栈、队列</title>
    <link href="https://rockspeechcoder.github.io/2022/07/06/xian-xing-shu-ju-jie-gou-shu-zu-lian-biao-zhan-dui-lie/"/>
    <id>https://rockspeechcoder.github.io/2022/07/06/xian-xing-shu-ju-jie-gou-shu-zu-lian-biao-zhan-dui-lie/</id>
    <published>2022-07-06T01:56:15.000Z</published>
    <updated>2022-10-13T15:00:38.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性数据结构-数组、链表、栈、队列"><a href="#线性数据结构-数组、链表、栈、队列" class="headerlink" title="线性数据结构 :数组、链表、栈、队列"></a>线性数据结构 :数组、链表、栈、队列</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p><p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p><p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p><pre class="line-numbers language-none"><code class="language-none">假如数组的长度为 n。访问：O（1）&#x2F;&#x2F;访问特定位置的元素插入：O（n ）&#x2F;&#x2F;最坏的情况发生在插入发生在数组的首部并需要移动所有元素时删除：O（n）&#x2F;&#x2F;最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://camo.githubusercontent.com/46f587fe2966892bbf19d0432c9793770e28f69a45a217428768b6912af7c606/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362539352542302545372542422538342e706e67"><img src="https://camo.githubusercontent.com/46f587fe2966892bbf19d0432c9793770e28f69a45a217428768b6912af7c606/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362539352542302545372542422538342e706e67" alt="数组"></a></p><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><h3 id="2-1-链表简介"><a href="#2-1-链表简介" class="headerlink" title="2.1. 链表简介"></a>2.1. 链表简介</h3><p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p><p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p><p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p><h3 id="2-2-链表分类"><a href="#2-2-链表分类" class="headerlink" title="2.2. 链表分类"></a>2.2. 链表分类</h3><p><strong>常见链表分类：</strong></p><ol><li>单链表</li><li>双向链表</li><li>循环链表</li><li>双向循环链表</li></ol><pre class="line-numbers language-none"><code class="language-none">假如链表中有n个元素。访问：O（n）&#x2F;&#x2F;访问特定位置的元素插入删除：O（1）&#x2F;&#x2F;必须要要知道插入元素的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-单链表"><a href="#2-2-1-单链表" class="headerlink" title="2.2.1. 单链表"></a>2.2.1. 单链表</h4><p><strong>单链表</strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p><p><a href="https://camo.githubusercontent.com/1d8bf245b30ede53ec1bcab9bd44708b70f880f174eb4f9d17af2dc3ee330d47/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254535253844253935254539253933254245254538254131254138322e706e67"><img src="https://camo.githubusercontent.com/1d8bf245b30ede53ec1bcab9bd44708b70f880f174eb4f9d17af2dc3ee330d47/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254535253844253935254539253933254245254538254131254138322e706e67" alt="单链表"></a></p><h4 id="2-2-2-循环链表"><a href="#2-2-2-循环链表" class="headerlink" title="2.2.2. 循环链表"></a>2.2.2. 循环链表</h4><p><strong>循环链表</strong> 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p><p><a href="https://camo.githubusercontent.com/3556e4a0b077e5cee95738f6b177929875f53d359b582af5e12b59188e8f5d8c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254535254245254141254537253845254146254539253933254245254538254131254138322e706e67"><img src="https://camo.githubusercontent.com/3556e4a0b077e5cee95738f6b177929875f53d359b582af5e12b59188e8f5d8c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254535254245254141254537253845254146254539253933254245254538254131254138322e706e67" alt="循环链表"></a></p><h4 id="2-2-3-双向链表"><a href="#2-2-3-双向链表" class="headerlink" title="2.2.3. 双向链表"></a>2.2.3. 双向链表</h4><p><strong>双向链表</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><p><a href="https://camo.githubusercontent.com/d7fd1913224b9e4bb2ac5aff7ac57097b1876de11c1744b21cfe6dcc9d2c05d6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67"><img src="https://camo.githubusercontent.com/d7fd1913224b9e4bb2ac5aff7ac57097b1876de11c1744b21cfe6dcc9d2c05d6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67" alt="双向链表"></a></p><h4 id="2-2-4-双向循环链表"><a href="#2-2-4-双向循环链表" class="headerlink" title="2.2.4. 双向循环链表"></a>2.2.4. 双向循环链表</h4><p><strong>双向循环链表</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p><a href="https://camo.githubusercontent.com/7e710661bccc541450e8726b61379a7b5bcc5bfdfb897bf8eb66568280fdcc9a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67"><img src="https://camo.githubusercontent.com/7e710661bccc541450e8726b61379a7b5bcc5bfdfb897bf8eb66568280fdcc9a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67" alt="双向循环链表"></a></p><h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3. 应用场景"></a>2.3. 应用场景</h3><ul><li>如果需要支持随机访问的话，链表没办法做到。</li><li>如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。</li><li>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</li></ul><h3 id="2-4-数组-vs-链表"><a href="#2-4-数组-vs-链表" class="headerlink" title="2.4. 数组 vs 链表"></a>2.4. 数组 vs 链表</h3><ul><li>数组支持随机访问，而链表不支持。</li><li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li><li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li></ul><h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h2><h3 id="3-1-栈简介"><a href="#3-1-栈简介" class="headerlink" title="3.1. 栈简介"></a>3.1. 栈简介</h3><p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p><p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p><pre class="line-numbers language-none"><code class="language-none">假设堆栈中有n个元素。访问：O（n）&#x2F;&#x2F;最坏情况插入删除：O（1）&#x2F;&#x2F;顶端插入和删除元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://camo.githubusercontent.com/6a7b6ad68765003b517ee559cf0b660f33ad97665ad317ce12de96cc692fbf5c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362541302538382e706e67"><img src="https://camo.githubusercontent.com/6a7b6ad68765003b517ee559cf0b660f33ad97665ad317ce12de96cc692fbf5c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362541302538382e706e67" alt="栈"></a></p><h3 id="3-2-栈的常见应用常见应用场景"><a href="#3-2-栈的常见应用常见应用场景" class="headerlink" title="3.2. 栈的常见应用常见应用场景"></a>3.2. 栈的常见应用常见应用场景</h3><p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 <strong>后进先出（LIFO, Last In First Out）</strong> 的特性时，我们就可以使用栈这个数据结构。</p><h4 id="3-2-1-实现浏览器的回退和前进功能"><a href="#3-2-1-实现浏览器的回退和前进功能" class="headerlink" title="3.2.1. 实现浏览器的回退和前进功能"></a>3.2.1. 实现浏览器的回退和前进功能</h4><p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:</p><p><a href="https://camo.githubusercontent.com/49ee24a13f80f001accee74a168091ba1cf88f49b1897b81a5d748f5209baa9c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362541302538382545352541452539452545372538452542302545362542352538462545382541372538382545352539392541382545352538302539322545392538302538302545352539322538432545352538392538442545382542462539422e706e67"><img src="https://camo.githubusercontent.com/49ee24a13f80f001accee74a168091ba1cf88f49b1897b81a5d748f5209baa9c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362541302538382545352541452539452545372538452542302545362542352538462545382541372538382545352539392541382545352538302539322545392538302538302545352539322538432545352538392538442545382542462539422e706e67" alt="栈实现浏览器倒退和前进"></a></p><h4 id="3-2-2-检查符号是否成对出现"><a href="#3-2-2-检查符号是否成对出现" class="headerlink" title="3.2.2. 检查符号是否成对出现"></a>3.2.2. 检查符号是否成对出现</h4><blockquote><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断该字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>比如 “()”、”()[]{}”、”{[]}” 都是有效字符串，而 “(]” 、”([)]” 则不是。</p></blockquote><p>这个问题实际是 Leetcode 的一道题目，我们可以利用栈 <code>Stack</code> 来解决这个问题。</p><ol><li>首先我们将括号间的对应规则存放在 <code>Map</code> 中，这一点应该毋容置疑；</li><li>创建一个栈。遍历字符串，如果字符是左括号就直接加入<code>stack</code>中，否则将<code>stack</code> 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果<code>stack</code>为空，返回 <code>true</code>。</li></ol><pre class="line-numbers language-none"><code class="language-none">public boolean isValid(String s)&#123;    &#x2F;&#x2F; 括号之间的对应规则    HashMap&lt;Character, Character&gt; mappings &#x3D; new HashMap&lt;Character, Character&gt;();    mappings.put(&#39;)&#39;, &#39;(&#39;);    mappings.put(&#39;&#125;&#39;, &#39;&#123;&#39;);    mappings.put(&#39;]&#39;, &#39;[&#39;);    Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();    char[] chars &#x3D; s.toCharArray();    for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;        if (mappings.containsKey(chars[i])) &#123;            char topElement &#x3D; stack.empty() ? &#39;#&#39; : stack.pop();            if (topElement !&#x3D; mappings.get(chars[i])) &#123;                return false;            &#125;        &#125; else &#123;            stack.push(chars[i]);        &#125;    &#125;    return stack.isEmpty();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-3-反转字符串"><a href="#3-2-3-反转字符串" class="headerlink" title="3.2.3. 反转字符串"></a>3.2.3. 反转字符串</h4><p>将字符串中的每个字符先入栈再出栈就可以了。</p><h4 id="3-2-4-维护函数调用"><a href="#3-2-4-维护函数调用" class="headerlink" title="3.2.4. 维护函数调用"></a>3.2.4. 维护函数调用</h4><p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p><h3 id="3-3-栈的实现"><a href="#3-3-栈的实现" class="headerlink" title="3.3. 栈的实现"></a>3.3. 栈的实现</h3><p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p><p>下面我们使用数组来实现一个栈，并且这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p><blockquote><p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public class MyStack &#123;    private int[] storage;&#x2F;&#x2F;存放栈中元素的数组    private int capacity;&#x2F;&#x2F;栈的容量    private int count;&#x2F;&#x2F;栈中元素数量    private static final int GROW_FACTOR &#x3D; 2;    &#x2F;&#x2F;不带初始容量的构造方法。默认容量为8    public MyStack() &#123;        this.capacity &#x3D; 8;        this.storage&#x3D;new int[8];        this.count &#x3D; 0;    &#125;    &#x2F;&#x2F;带初始容量的构造方法    public MyStack(int initialCapacity) &#123;        if (initialCapacity &lt; 1)            throw new IllegalArgumentException(&quot;Capacity too small.&quot;);        this.capacity &#x3D; initialCapacity;        this.storage &#x3D; new int[initialCapacity];        this.count &#x3D; 0;    &#125;    &#x2F;&#x2F;入栈    public void push(int value) &#123;        if (count &#x3D;&#x3D; capacity) &#123;            ensureCapacity();        &#125;        storage[count++] &#x3D; value;    &#125;    &#x2F;&#x2F;确保容量大小    private void ensureCapacity() &#123;        int newCapacity &#x3D; capacity * GROW_FACTOR;        storage &#x3D; Arrays.copyOf(storage, newCapacity);        capacity &#x3D; newCapacity;    &#125;    &#x2F;&#x2F;返回栈顶元素并出栈    private int pop() &#123;        if (count &#x3D;&#x3D; 0)            throw new IllegalArgumentException(&quot;Stack is empty.&quot;);        count--;        return storage[count];    &#125;    &#x2F;&#x2F;返回栈顶元素不出栈    private int peek() &#123;        if (count &#x3D;&#x3D; 0)&#123;            throw new IllegalArgumentException(&quot;Stack is empty.&quot;);        &#125;else &#123;            return storage[count-1];        &#125;    &#125;    &#x2F;&#x2F;判断栈是否为空    private boolean isEmpty() &#123;        return count &#x3D;&#x3D; 0;    &#125;    &#x2F;&#x2F;返回栈中元素的个数    private int size() &#123;        return count;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证</p><pre class="line-numbers language-none"><code class="language-none">MyStack myStack &#x3D; new MyStack(3);myStack.push(1);myStack.push(2);myStack.push(3);myStack.push(4);myStack.push(5);myStack.push(6);myStack.push(7);myStack.push(8);System.out.println(myStack.peek());&#x2F;&#x2F;8System.out.println(myStack.size());&#x2F;&#x2F;8for (int i &#x3D; 0; i &lt; 8; i++) &#123;    System.out.println(myStack.pop());&#125;System.out.println(myStack.isEmpty());&#x2F;&#x2F;truemyStack.pop();&#x2F;&#x2F;报错：java.lang.IllegalArgumentException: Stack is empty.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h2><h3 id="4-1-队列简介"><a href="#4-1-队列简介" class="headerlink" title="4.1. 队列简介"></a>4.1. 队列简介</h3><p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p><p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p><pre class="line-numbers language-none"><code class="language-none">假设队列中有n个元素。访问：O（n）&#x2F;&#x2F;最坏情况插入删除：O（1）&#x2F;&#x2F;后端插入前端删除元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://camo.githubusercontent.com/1cccc99cbd4ebea2d6052101ec02eeac55c4d69c70cca50724aec43f13d9b14d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382539462545352538382539372e706e67"><img src="https://camo.githubusercontent.com/1cccc99cbd4ebea2d6052101ec02eeac55c4d69c70cca50724aec43f13d9b14d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382539462545352538382539372e706e67" alt="队列"></a></p><h3 id="4-2-队列分类"><a href="#4-2-队列分类" class="headerlink" title="4.2. 队列分类"></a>4.2. 队列分类</h3><h4 id="4-2-1-单队列"><a href="#4-2-1-单队列" class="headerlink" title="4.2.1. 单队列"></a>4.2.1. 单队列</h4><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p><p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p><p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。</p><blockquote><p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》</p></blockquote><p><a href="https://camo.githubusercontent.com/2c7f7db9b67ac298f2a0fd7983fb4c3a5cf4ee11a2f6070fcc82af6f42fdf71c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254539254131254241254535254241253846254539253938253946254535253838253937254535253831253837254536254241254132254535253837254241312e706e67"><img src="https://camo.githubusercontent.com/2c7f7db9b67ac298f2a0fd7983fb4c3a5cf4ee11a2f6070fcc82af6f42fdf71c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254539254131254241254535254241253846254539253938253946254535253838253937254535253831253837254536254241254132254535253837254241312e706e67" alt="顺序队列假溢出"></a></p><h4 id="4-2-2-循环队列"><a href="#4-2-2-循环队列" class="headerlink" title="4.2.2. 循环队列"></a>4.2.2. 循环队列</h4><p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p><p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p><p><a href="https://camo.githubusercontent.com/eb679149c00da98b44d7b5dbd1fa11fd17f80ecda9d3580d5dcffe9ceb2a2460/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352542452541412545372538452541462545392539382539462545352538382539372e706e67"><img src="https://camo.githubusercontent.com/eb679149c00da98b44d7b5dbd1fa11fd17f80ecda9d3580d5dcffe9ceb2a2460/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352542452541412545372538452541462545392539382539462545352538382539372e706e67" alt="循环队列"></a></p><p>顺序队列中，我们说 <code>front==rear</code> 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p><ol><li>可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且 <code>flag=1</code> 的时候队列为满。</li><li>队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： <code>(rear+1) % QueueSize= front</code> 。</li></ol><p><a href="https://camo.githubusercontent.com/fe8ca177732ef10b11746882e611f13b048e26f291372edcea1709b50485e6b1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352542452541412545372538452541462545392539382539462545352538382539372d2545352541302538362545362542422541312e706e67"><img src="https://camo.githubusercontent.com/fe8ca177732ef10b11746882e611f13b048e26f291372edcea1709b50485e6b1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352542452541412545372538452541462545392539382539462545352538382539372d2545352541302538362545362542422541312e706e67" alt="循环队列-队满"></a></p><h3 id="4-3-常见应用场景"><a href="#4-3-常见应用场景" class="headerlink" title="4.3. 常见应用场景"></a>4.3. 常见应用场景</h3><p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p><ul><li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li><li><strong>线程池中的请求/任务队列：</strong> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li><li>Linux 内核进程队列（按优先级排队）</li><li>现实生活中的派对，播放器上的播放列表;</li><li>消息队列</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性数据结构-数组、链表、栈、队列&quot;&gt;&lt;a href=&quot;#线性数据结构-数组、链表、栈、队列&quot; class=&quot;headerlink&quot; title=&quot;线性数据结构 :数组、链表、栈、队列&quot;&gt;&lt;/a&gt;线性数据结构 :数组、链表、栈、队列&lt;/h1&gt;&lt;h2 id=&quot;1-数</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://rockspeechcoder.github.io/2022/06/13/jvm/"/>
    <id>https://rockspeechcoder.github.io/2022/06/13/jvm/</id>
    <published>2022-06-13T11:06:11.000Z</published>
    <updated>2022-10-13T15:29:47.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM入门【持续补充】"><a href="#JVM入门【持续补充】" class="headerlink" title="JVM入门【持续补充】"></a>JVM入门【持续补充】</h1><h2 id="jvm的位置"><a href="#jvm的位置" class="headerlink" title="jvm的位置"></a>jvm的位置</h2><img src="/2022/06/13/jvm/image-1.png" class=""><h2 id="jvm的体系结构"><a href="#jvm的体系结构" class="headerlink" title="jvm的体系结构"></a>jvm的体系结构</h2><ul><li>源文件由编译器编译成字节码（ByteCode） </li><li>字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行</li></ul><img src="/2022/06/13/jvm/image-2.png" class=""><ol><li><p>类加载器（Class Loader）子系统</p></li><li><p>执行引擎（Execution Engine）</p></li><li><p>运行时数据区(Runtime Data Area)</p><ul><li><p>线程私有数据区（不会有垃圾回收）</p><ol><li><p>Java栈 VM Stack</p><ul><li><p>是Java方法执行的内存模型。</p></li><li><p><strong>Java栈中存放的是一个个的栈帧，</strong> 每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。</p></li><li><p>当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。</p></li><li><p>会有两种异常StackOverFlowError和 OutOfMemoryError。当线程请求栈深度大于虚拟机所允许的深度就会抛出StackOverFlowError错误；虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出OutOfMemoryError。它是线程私有的，生命周期与线程相同。</p></li></ul></li><li><p>本地方法栈 Native Method</p><ul><li>Java栈是为执行Java方法服务的， 而本地方法栈则是为执行本地方法（Native Method）服务的。</li><li>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</li><li>在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。</li></ul></li><li><p>程序计数器 Program Counter Register</p><ul><li>程序计数器是一块较小的内存空间， <strong>可以看作是当前线程所执行的字节码的行号指示器。</strong> 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储</strong>，我们称这类内存区域为 <strong>“线程私有”</strong> 的内存。</li><li>如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。</li><li>程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)</li></ul></li></ol></li><li><p>线程共享数据区（需要垃圾回收：堆）</p><ol><li>方法区Method Area<ul><li>用于存储类信息（构造方法、接口定义）、常量池、静态变量、JIT编译后的代码等数据，（永久代是HotSpot虚拟机特有的概念，是对方法区的实现，别的JVM没有永久代的概念） </li><li>被所有线程共享</li></ul></li><li>堆 heap</li></ol></li></ul></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>作用：加载class文件</li></ul> <img src="/2022/06/13/jvm/image-3.png" class=""> <img src="/2022/06/13/jvm/image-4.png" class=""><ul><li>分类（对象.getClass().getClassLoader()）<ol><li>虚拟机自带的加载器</li><li>启动类（根）加载器（/jre/lib/rt.jar）</li><li>扩展类加载器（/jre/lib/ext）</li><li>应用程序加载器</li></ol></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ol><li>类加载器收到类加载的请求</li><li>将请求向上委托给父类加载器中，一直向上委托，能加载就结束并使用当前加载器。APP类加载器 –&gt; ext加载器 –&gt; BOOT（最终执行）</li><li>不能加载则抛出异常（Class not found），通知子加载器进行加载</li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ol><li><p>Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱<strong>主要限制系统资源访问</strong>，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p></li><li><p>安全模型</p><p>当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示 最新的安全模型(jdk 1.6)<br><img src="https://img-blog.csdn.net/20181022103108566?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMzM2NDMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p></li><li><p>doPrivileged 方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。</p></li><li><p>基本组件：</p><ul><li><p>字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</p></li><li><p>类装载器</p><p>（class loader）：其中类装载器在3个方面对Java沙箱起作用</p><ul><li>它防止恶意代码去干涉善意的代码；</li><li>它守护了被信任的类库边界；</li><li>它将代码归入保护域，确定了代码可以进行哪些操作。</li></ul></li></ul><p>  虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。</p><ul><li>存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</li><li>安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li><li>安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：<ul><li>安全提供者</li><li>消息摘要</li><li>数字签名</li><li>加密</li><li>鉴别</li></ul></li></ul></li><li><p>要素：</p><ol><li>权限</li><li>代码源</li><li>保护欲</li><li>策略文件</li><li>密钥库</li></ol></li></ol><h2 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h2><ul><li><p>超出java的作用范围，去调底层c库</p></li><li><p>会进入本地方法栈，调用本地方法接口（JNI），扩展java的使用</p></li><li><p>本地方法栈，登记本地native方法</p></li><li><p>最终执行时通过JNI加载本地方法库</p></li></ul><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2> <img src="/2022/06/13/jvm/image-6.png" class=""><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>一个JVM只有一个堆内存，大小可以调节</p></li><li><p>保存类、方法、常量、变量、引用类型的真实对象</p></li><li><p>分区</p><ul><li><p>新生区</p><ul><li>类的初始至结束</li><li>伊甸园区（Eden） –&gt;满了触发轻GC</li><li>幸存者0区</li><li>幸存者1区</li></ul></li><li><p>养老区（Old）</p></li><li><p>永久区（Perm）【逻辑上存在，物理上不存在，有人称为非堆】</p><ul><li><p>常驻内存，用来存放JDK自身携带的对象，interface元数据，存储的是JAVA运行时的环境和类信息</p></li><li><p>不存在垃圾回收</p></li><li><p>关闭虚拟机会释放内存</p></li><li><p>jdk6之前，永久代，常量池在方法区</p></li><li><p>jdk7，永久代，常量池在堆中</p></li><li><p>jdk8之后，无永久代，称为元空间，常量池在元空间</p></li></ul></li></ul></li></ul><h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><ul><li><p>轻量级GC 新生区</p><p>伊甸园区满了会触发轻GC，有的对象仍存在引用，存到幸存者区。幸存者区满了进养老区</p></li><li><p>重量级GC 新生区和养老区</p><p>新生区满了触发重GC（据调查，99%的对象是临时对象）</p></li></ul><h2 id="OOM问题（OutOfMemoryError）"><a href="#OOM问题（OutOfMemoryError）" class="headerlink" title="OOM问题（OutOfMemoryError）"></a>OOM问题（OutOfMemoryError）</h2><ol><li><p>尝试扩大堆内存</p><p>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</p></li><li><p>JProfile分析内存，内存快照分析工具</p><ol><li><p>分析Dump内存文件，快速定位内存泄露</p><p>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemory</p><p>// -Xms 设置初始化内存分配大小</p><p>// -Xmx 设置最大分配内存</p></li></ol></li></ol> <img src="/2022/06/13/jvm/image-6.png" class=""> <img src="/2022/06/13/jvm/image-7.png" class=""><ol start="2"><li>获得堆中的数据</li><li>获得大的对象</li></ol><h2 id="GC引用计数法"><a href="#GC引用计数法" class="headerlink" title="GC引用计数法"></a>GC引用计数法</h2> <img src="/2022/06/13/jvm/image-8.png" class=""><h2 id="GC复制算法"><a href="#GC复制算法" class="headerlink" title="GC复制算法"></a>GC复制算法</h2><ul><li>主要用于年轻代</li><li>好处：没有内存的碎片</li><li>坏处：浪费了内存空间，有一半空间是空的（to区）</li><li>最佳使用场景：对象存活度较低</li></ul> <img src="/2022/06/13/jvm/image-9.png" class=""> <img src="/2022/06/13/jvm/image-10.png" class=""><h2 id="GC标记压缩清除算法"><a href="#GC标记压缩清除算法" class="headerlink" title="GC标记压缩清除算法"></a>GC标记压缩清除算法</h2><ul><li><p>描述</p><ol><li><p>扫描对象，对活着的对象进行标记</p></li><li><p>对没有标记的对象进行清除</p></li></ol></li></ul> <img src="/2022/06/13/jvm/image-11.png" class=""><ul><li><p>优点：不需要额外的空间</p></li><li><p>缺点：两次扫描，严重浪费时间，产生内存碎片</p></li><li><p>再优化：压缩：防止内存碎片</p><ul><li><p>再次扫描，多了移动成本</p></li><li><p>多次清除后再压缩节约成本</p></li></ul></li></ul> <img src="/2022/06/13/jvm/image-12.png" class=""><h2 id="GC算法总结"><a href="#GC算法总结" class="headerlink" title="GC算法总结"></a>GC算法总结</h2><ul><li>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法（时间复杂度）</li><li>内存整齐度：复制算法 = 标记压缩算法 &gt; 标记清除算法</li><li>内存利用率：标记压缩算法 = 标记清除算法 &gt; 复制算法</li></ul><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>年轻代：存活率低，复制算法</p><p>老年代：区域大，存活率高，标记清除和标记压缩混合实现</p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><ol><li><p>描述：</p><ul><li><p>java内存模型 ，java memory model。 </p><img src="/2022/06/13/jvm/image-13.png" class=""></li><li><p>定义了线程工作内存和主内存的抽象关系，线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）</p></li></ul></li></ol> <img src="/2022/06/13/jvm/image-14.png" class=""><ul><li>缓存一致性协议，用于定义数据读写的规则</li></ul><ol start="2"><li><p>volilate 解决对象可见性</p><ul><li>表示这个变量在不同线程中是共享，编译器与运行时都会注意到这个变量是<strong>共享</strong>的，因此不会对该变量进行<strong>重排序</strong>。</li><li>volatile关键字保证可见性、有序性。但不保证原子性。</li></ul></li><li><p><strong>JMM的八种交互操作</strong>（每个操作都为<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020">原子操作</a>）</p><ul><li>lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li><li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li><li>use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li><li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li><li>store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li><li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li></ul></li><li><p>八种操作的规则</p><ul><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li><li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li><li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作</li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM入门【持续补充】&quot;&gt;&lt;a href=&quot;#JVM入门【持续补充】&quot; class=&quot;headerlink&quot; title=&quot;JVM入门【持续补充】&quot;&gt;&lt;/a&gt;JVM入门【持续补充】&lt;/h1&gt;&lt;h2 id=&quot;jvm的位置&quot;&gt;&lt;a href=&quot;#jvm的位置&quot; cla</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA-IO</title>
    <link href="https://rockspeechcoder.github.io/2022/04/30/java-io/"/>
    <id>https://rockspeechcoder.github.io/2022/04/30/java-io/</id>
    <published>2022-04-30T03:42:56.000Z</published>
    <updated>2022-10-13T15:14:21.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-IO"><a href="#JAVA-IO" class="headerlink" title="JAVA-IO"></a>JAVA-IO</h1><h2 id="InputStream-字节输入流"><a href="#InputStream-字节输入流" class="headerlink" title="InputStream-字节输入流"></a>InputStream-字节输入流</h2><ul><li>继承关系</li></ul><ul><li><p>分类：</p><ul><li><p>FileInputStream 文件输入流</p></li><li><p>BufferedInputStream 缓冲输入流</p></li><li><p>ObjectInputStream 对象输入流</p></li></ul></li></ul><h2 id="OutputStream-字节输出流"><a href="#OutputStream-字节输出流" class="headerlink" title="OutputStream-字节输出流"></a>OutputStream-字节输出流</h2><ul><li>继承关系</li></ul><ul><li><p>分类</p><ul><li>FileOutputStream 文件输出流</li><li>BufferedOutputStream 缓冲输出流</li><li>ObjectOutputStream 对象输出流</li><li>PrintStream 打印输出流</li></ul></li></ul><h2 id="Reader-字符输入流"><a href="#Reader-字符输入流" class="headerlink" title="Reader-字符输入流"></a>Reader-字符输入流</h2><ul><li>继承关系</li></ul><ul><li><p>分类</p><ul><li>FileReader 文件输入流</li><li>BufferedReader 缓冲输入流</li></ul></li></ul><h2 id="Writer-字符输出流"><a href="#Writer-字符输出流" class="headerlink" title="Writer-字符输出流"></a>Writer-字符输出流</h2><ul><li>继承关系</li></ul><ul><li><p>分类</p><ul><li><p>FileWriter 文件输出流</p></li><li><p>BufferedWriter 缓冲输出流</p></li><li><p>PrintWriter 打印输出流</p></li></ul></li></ul><h2 id="节点流与处理流"><a href="#节点流与处理流" class="headerlink" title="节点流与处理流"></a>节点流与处理流</h2><ol><li><p>节点流</p><p>可以从一个特定的数据源读写数据，如FileReader、FileWriter</p></li><li><p>处理流（包装流）</p><p>连接在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter。</p><ul><li><p>对象流ObjectInputStream和ObjectOutputStream，需要将基本类型或对象进行序列化和反序列化操作，保存数据的值和数据类型。其类需要实现Serializable</p></li><li><p>以缓冲的方式提高输入输出效率</p></li><li><p>提供一系列便捷的方法来一次输入输出大批量的数据，更加灵活。使用装饰器设计模式，不与直接数据源相连</p></li></ul></li></ol><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ul><li><p>InputStreamReader</p><p>Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）</p></li></ul><ul><li><p>OutputStreamWriter</p><p>Writer的子类，可以将OutputStream（字节流）包装成Writer（字符流）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA-IO&quot;&gt;&lt;a href=&quot;#JAVA-IO&quot; class=&quot;headerlink&quot; title=&quot;JAVA-IO&quot;&gt;&lt;/a&gt;JAVA-IO&lt;/h1&gt;&lt;h2 id=&quot;InputStream-字节输入流&quot;&gt;&lt;a href=&quot;#InputStream-字节输入</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="https://rockspeechcoder.github.io/2022/02/17/redis/"/>
    <id>https://rockspeechcoder.github.io/2022/02/17/redis/</id>
    <published>2022-02-17T13:09:31.000Z</published>
    <updated>2022-10-13T16:06:25.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>REmote DIctionary Server(Redis) 是 key-value 存储系统，是跨平台的非关系型数据库。</p><p>redis基于内存操作，cpu不是redis性能瓶颈，瓶颈是根据机器的内存和网络带宽，单线程。多线程会产生cpu上下文的切换，耗时</p> <img src="/2022/02/17/redis/image-1.png" class=""><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p><strong>高性能</strong></p><p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p><strong>高并发</strong></p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><blockquote><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数</p></blockquote><h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><ul><li><p><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p><ul><li>String</li></ul><img src="/2022/02/17/redis/image-2.png" class=""><img src="/2022/02/17/redis/image-3.png" class=""><img src="/2022/02/17/redis/image-4.png" class=""><img src="/2022/02/17/redis/image-5.png" class=""><img src="/2022/02/17/redis/image-6.png" class=""><img src="/2022/02/17/redis/image-7.png" class=""><img src="/2022/02/17/redis/image-8.png" class=""><img src="/2022/02/17/redis/image-9.png" class=""><ul><li>List</li></ul> <img src="/2022/02/17/redis/image-10.png" class=""> <img src="/2022/02/17/redis/image-11.png" class=""> <img src="/2022/02/17/redis/image-12.png" class=""> <img src="/2022/02/17/redis/image-13.png" class=""> <img src="/2022/02/17/redis/image-14.png" class=""> <img src="/2022/02/17/redis/image-15.png" class=""> <img src="/2022/02/17/redis/image-16.png" class=""> <img src="/2022/02/17/redis/image-17.png" class=""> <img src="/2022/02/17/redis/image-18.png" class=""><ul><li>Set</li></ul> <img src="/2022/02/17/redis/image-19.png" class=""> <img src="/2022/02/17/redis/image-20.png" class=""> <img src="/2022/02/17/redis/image-21.png" class=""> <img src="/2022/02/17/redis/image-22.png" class=""> <img src="/2022/02/17/redis/image-23.png" class=""> <img src="/2022/02/17/redis/image-24.png" class=""><ul><li>Hash</li></ul> <img src="/2022/02/17/redis/image-25.png" class=""> <img src="/2022/02/17/redis/image-26.png" class=""><p>  <img src="C:\Users\yangz\AppData\Roaming\Typora\typora-user-images\image-20220923193049607.png" alt="image-20220923193049607"></p></li></ul><img src="/2022/02/17/redis/image-27.png" class=""><img src="/2022/02/17/redis/image-28.png" class=""><ul><li>Zset（有序集合）</li></ul><img src="/2022/02/17/redis/image-29.png" class=""><img src="/2022/02/17/redis/image-30.png" class=""><img src="/2022/02/17/redis/image-31.png" class=""><img src="/2022/02/17/redis/image-32.png" class=""><ul><li><p><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</p><ul><li>Geospatial </li></ul><img src="/2022/02/17/redis/image-33.png" class=""><img src="/2022/02/17/redis/image-34.png" class=""><img src="/2022/02/17/redis/image-35.png" class=""><img src="/2022/02/17/redis/image-36.png" class=""><img src="/2022/02/17/redis/image-37.png" class=""><img src="/2022/02/17/redis/image-38.png" class=""><ul><li><p>Hyperloglog基数</p><p>优点：查找不重复的元素，占内存小，12k内存，可以用于统计网页uv，比传统set方式节省空间</p>  <img src="/2022/02/17/redis/image-39.png" class=""><pre><code>&#123;% asset_img image-40.png %&#125;</code></pre></li><li><p>Bitmaps位图</p></li></ul><img src="/2022/02/17/redis/image-41.png" class=""><img src="/2022/02/17/redis/image-42.png" class=""><img src="/2022/02/17/redis/image-43.png" class=""></li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><ol><li>redis-benchmark -h localhost -p 6379 -c 100 -n 100000</li></ol><p>​        -c 100 100个并发连接</p><p>​        -n 100000 每个连接100000个请求</p><p>​    <img src="C:\Users\yangz\AppData\Roaming\Typora\typora-user-images\image-20220921230507325.png" alt="image-20220921230507325"></p><ol start="2"><li>分析</li></ol><p><img src="C:\Users\yangz\AppData\Roaming\Typora\typora-user-images\image-20220921230332185.png" alt="image-20220921230332185"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>一组命令的集合。一个事务中的所有命令会被序列化。事务执行时按顺序执行。redis单条命令是保证原子性的，但是事务不保证原子性，没有隔离级别的概念。</p></li><li><p>三个阶段</p><ul><li>开启事务</li><li>命令入队</li><li>执行事务</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">multiset k1 v1set k2 v2get k1exec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>取消事务 <code>dicard</code></li></ul></li><li><p>异常</p><ul><li><p>编译型异常</p>  <img src="/2022/02/17/redis/image-44.png" class=""></li><li><p>运行时异常</p>  <img src="/2022/02/17/redis/image-45.png" class=""></li></ul></li><li><p>乐观锁，监视测试</p><ul><li><p>获取version</p></li><li><p>更新的时候比较version</p></li><li><p>事务执行失败，解锁unwatch</p>  <img src="/2022/02/17/redis/image-46.png" class="">  <img src="/2022/02/17/redis/image-47.png" class=""></li></ul></li></ul><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><ol><li><p>依赖</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;dependencies&gt;    &lt;!--导入Jedis的包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.2.3&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--导入fastjson的包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.0.13&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试ping</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestPingRedis &#123;    public static void main(String[] args) &#123;        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;,6379);        System.out.println(jedis.ping());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试事务</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;,6379);    jedis.flushDB();    JSONObject jsonObject &#x3D; new JSONObject();    jsonObject.put(&quot;a&quot;,&quot;one&quot;);    jsonObject.put(&quot;b&quot;,&quot;two&quot;);    jsonObject.put(&quot;c&quot;,&quot;three&quot;);    &#x2F;&#x2F; 开启事务    Transaction transaction &#x3D; jedis.multi();    try&#123;        transaction.set(&quot;json1&quot;,jsonObject.toString());        transaction.set(&quot;json2&quot;,jsonObject.toString());        transaction.exec();    &#125;    catch(Exception e)&#123;        transaction.discard();        e.printStackTrace();    &#125;finally &#123;        System.out.println(jedis.get(&quot;json1&quot;));        System.out.println(jedis.get(&quot;json2&quot;));        jedis.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><p>springboot 2.x后，jedis被替换为了lettuce。jedis多个线程操作不安全，jedis pool（BIO）。lettuce采用netty，可以在多个线程中共享（NIO）</p><pre><code>  &#123;% asset_img image-48.png %&#125;</code></pre><p>Redis配置文件</p><ul><li><p>network</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bind 127.0.0.1 #绑定ipprotected-mode yes #保护模式port 6379 #端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>general</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">daemonize yes #守护进程的方式运行，默认是nopidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid #指定后台运行的pid文件loglevel notice # 日志等级logfile &quot;&quot; # 日志文件位置databases 16 # 数据库数量，默认16个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>快照</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save 3600 100 # 规定时间内，做了多少次操作会持久化到文件.rdb .aofstop-writes-on-bgsave-error yes # 持久化出错是否继续工作rdbcompression yes # 是否压缩rdb文件rdbchecksum yes # 保存rdb文件的时候错误校验dir .&#x2F; # rdb文件的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安全</p><pre class="line-numbers language-none"><code class="language-none">requirepass password # 设置密码，命令config set requirepass &quot;password&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>限制</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">maxclients 1000 # 设置连接redis客户端最大数量maxmemory &lt;bytes&gt; # redis配置最大的内存容量maxmemory-policy noeviction # 内存到达上限的处理策略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>maxmemory-policy</p><ol><li><p>volatile-lru：只对设置了过期时间的key进行LRU（默认值） </p></li><li><p>allkeys-lru ： 删除lru算法的key  </p></li><li><p>volatile-random：随机删除即将过期key  </p></li><li><p>allkeys-random：随机删除  </p></li><li><p>volatile-ttl ： 删除即将过期的  </p></li><li><p>noeviction ： 永不过期，返回错误</p></li></ol></li></ul></li><li><p>Append Only模式 aof配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly no # 默认不开启aof，默认使用rdb方式持久化appendfsync everysec # 每秒执行一次sync，可能丢失1s的数据appendfsync always # 每次修改执行sync，消耗性能appendfsync no # 不执行sync，操作系统自己同步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="持久化RDB（redis-database）"><a href="#持久化RDB（redis-database）" class="headerlink" title="持久化RDB（redis database）"></a>持久化RDB（redis database）</h2><pre><code>  &#123;% asset_img image-49.png %&#125;</code></pre><ul><li><p>描述：</p><p>​        Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了。再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF更加高效，RDB的缺点是最后一次持久化后的数据可能丢失。</p></li><li><p>触发机制</p><ul><li>save规则满足，自动触发</li><li>执行flushall命令</li><li>退出redis</li></ul></li><li><p>恢复rdb文件</p><ol><li>将rdb文件放在redis启动目录，redis启动自动检查</li><li>config get dir 得到启动目录</li></ol></li><li><p>优点</p><ul><li><p>适合大规模的数据恢复</p></li><li><p>对数据的完整性要求不高</p></li></ul></li><li><p>缺点</p><ul><li>需要一定的时间间隔进行操作，如果redis意外宕机，最后一次修改的数据会丢失</li><li>fork进程占用一定的内存空间</li></ul></li></ul><h2 id="持久化AOF（Append-Only-File）"><a href="#持久化AOF（Append-Only-File）" class="headerlink" title="持久化AOF（Append Only File）"></a>持久化AOF（Append Only File）</h2><ul><li><p>描述</p><p>将所有的命令记录下来放入history文件，恢复的时候执行此文件。以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件，但是不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p></li></ul><img src="/2022/02/17/redis/image-50.png" class=""><ul><li><p>优点</p><ul><li>每次修改都同步，文件的完整性好</li><li>每秒同步，可能会丢失一秒的数据</li><li>从不同步效率最高</li></ul></li><li><p>缺点</p><ul><li>aof文件数据较大，修复速度慢</li><li>aof运行效率慢</li></ul></li></ul><h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><p>原理;</p><p>通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道!，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。</p><p>通过PUBLSH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><ul><li><p>描述：</p><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(masterleader)，后者称为从节点(slave/follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p></li><li><p>作用：</p><ul><li>数据冗余：实现了数据的热备份</li><li>故障恢复：主节点出现故障，从节点提供服务</li><li>负载均衡：在主从复制的基础上，配合读写分离，分担服务器负载，提高服务器的并发量</li><li>高可用集群的基础</li></ul></li><li><p>查看当前库的信息：info-replication</p></li></ul><img src="/2022/02/17/redis/image-51.png" class=""><ul><li><p>操作步骤</p><ol><li>复制配置文件</li><li>修改端口、pid、log文件名字、dump.rdb名字</li></ol></li></ul><img src="/2022/02/17/redis/image-52.png" class=""><ul><li><p>配置从机</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">slaveof 127.0.0.1 6379 # 从属于主机的地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><img src="/2022/02/17/redis/image-53.png" class=""><ul><li><p>复制原理</p><p>Slave启动成功连接到master后会发送一个sync命令<br>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><ul><li>全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</li></ul></li></ul><img src="/2022/02/17/redis/image-54.png" class=""><ul><li><p>salveof no one</p><p>如果主机断开了连接，可以使用这个命令来让自己成为主节点，其他的结点就可以手动连接到最新的这个主节点。如果这个时候主机修复了，那就只能重新连接</p></li></ul><h2 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h2><ul><li><p>原理</p><p>Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong></p></li></ul><img src="/2022/02/17/redis/image-55.png" class=""><ul><li><p>作用</p><ol><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机</li></ol></li><li><p>多哨兵模式</p><p>一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p>哨兵1先检测到主机宕机，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。如果主机此时回来了，只能归并到新的主机下，当做从机。</p></li></ul><img src="/2022/02/17/redis/image-56.png" class=""><ul><li>配置sentinel.conf</li></ul><img src="/2022/02/17/redis/image-57.png" class=""><ul><li><p>启动哨兵</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-sentinel ..&#x2F;etc&#x2F;sentinal.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>优点</p><ol><li>哨兵模式，基于主从复制模式，所有主从配置的优点它都有</li><li>主从可以切换，故障可以转移，系统的可用性就会更好</li><li>哨兵模式就是主从模式的升级，手动到自动，更加健壮</li></ol></li><li><p>缺点</p><ol><li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置是比较复杂</li></ol></li><li><p>哨兵配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379port 26379 # 哨兵sentinel的工作目录dir &#x2F;tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd  # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1   # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。  #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了# 默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，#一个是事件的类型，#一个是事件的描述。#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。#通知脚本# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;  sentinel notification-script mymaster &#x2F;var&#x2F;redis&#x2F;notify.sh # 客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。# 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”,# &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;sentinel client-reconfig-script mymaster &#x2F;var&#x2F;redis&#x2F;reconfig.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Redis缓存穿透"><a href="#Redis缓存穿透" class="headerlink" title="Redis缓存穿透"></a>Redis缓存穿透</h2><ul><li><p>描述：</p><p>用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p></li><li><p>方案</p><ul><li><p>布隆过滤器</p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力</p></li></ul></li></ul><img src="/2022/02/17/redis/image-58.png" class=""><ul><li><p>缓存空对象</p><p>缓存中存储较多无意义的空对象</p><p>缓存层和存储层的数据可能会出现数据不一致的情况</p></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li><p>描述：缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，并且回写缓存，会导使数据库瞬间压力过大。</p></li><li><p>解决方案</p><ul><li><p>设置热点数据永不过期</p><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题、</p></li><li><p>加互斥锁</p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁考验很大</p></li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li><p>描述</p><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效，产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增。Redis宕机。</p></li><li><p>解决方案</p><ul><li>Redis高可用：多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</li><li>限流降级：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li><li>数据预热：在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA反射</title>
    <link href="https://rockspeechcoder.github.io/2022/01/13/java-fan-she/"/>
    <id>https://rockspeechcoder.github.io/2022/01/13/java-fan-she/</id>
    <published>2022-01-13T14:10:08.000Z</published>
    <updated>2022-10-13T15:17:41.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h1><h2 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h2><p>在不修改源码的前提下，扩展功能</p><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>允许程序在执行期间借助于Reflection API取得任何类的内部信息（比如成员变量、构造器、成员方法等），并能操作对象的属性和方法。</p><p>加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构，称之为反射</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><ol><li>java.lang.Class</li><li>java.lang.reflect.Method</li><li>java.lang.reflect.Field</li><li>java.lang.reflect.Constructor</li></ol><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：可以动态的创建对象和使用对象（框架底层核心），使用灵活</p><p>缺点：使用反射基本是解释执行，对执行速度有影响</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li><p>Method和Field、Constructor对象都有setAccessible()方法</p></li><li><p>setAccessible()是启用和禁用访问安全检查的开关</p></li><li><p>参数值为true表示反射对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查。</p></li></ul><h2 id="Class类的特点"><a href="#Class类的特点" class="headerlink" title="Class类的特点"></a>Class类的特点</h2><ol><li><p>class类也是类，同样继承Object类</p></li><li><p>Class类对象不是new出来的，而是系统创建的</p></li><li><p>某个类的class对象，在内存中只有一份，因为类只加载一次</p></li><li><p>每个类的实例都知道自己由哪个Class实例生成</p></li><li><p>通过Class对象可以完整的得到一个类的完整结构</p></li><li><p>Class对象放在堆中</p></li><li><p>类的字节码二进制数据放在方法区（元数据）</p></li></ol><h2 id="获取Class类对象"><a href="#获取Class类对象" class="headerlink" title="获取Class类对象"></a>获取Class类对象</h2><ol><li><p>已知一个类的全类名，且该类在类路径下。Class类的静态方法</p><p><code>Class cls = Class.forName(&quot;全类名&quot;)</code></p><p>应用场景：用于读取配置文件的全类名，加载类</p></li><li><p>若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高</p><p><code>Class cls = Cat.class</code></p><p>应用场景：多用于参数传递，比如通过反射得到对应构造器对象</p></li><li><p>已知某个类的实例，调用该实例的getClass()方法获取Class对象。</p><p><code>Class cls = 对象.getClass()</code></p><p>应用场景：通过创建好的对象，获取Class对象</p></li><li><p><code>ClassLoader cl = 对象.getClassLoader();</code></p><p><code>Class clz = cl.loadClass(&quot;全类名&quot;);</code></p></li><li><p>基本数据类型</p><p><code>Class&lt;Integer&gt; clz = int.class;</code></p></li><li><p>基本数据类型对应的包装类</p><p><code>Class clz = 包装类.TYPE</code></p></li></ol><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><ul><li><p>静态加载</p><p>编译时加载相关的类，如果没有则报错，依赖性太强</p></li><li><p>动态加载</p><p>运行时加载需要的类，如果运行时不使用该类，则不报错，降低了依赖性</p></li><li><p>类加载时机</p><ul><li>静态<ul><li>当创建对象时</li><li>当子类被加载时</li><li>调用类中的静态成员时</li></ul></li><li>动态<ul><li>通过反射</li></ul></li></ul></li></ul><h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h2><ol><li><p>加载（Loading）</p><p>将类的class文件读入内存，并为之创建一个java.lang.Class对象，此过程由类加载器完成</p></li><li><p>连接（Linking）</p><p>将类的二进制数据合并到JRE中</p></li><li><p>初始化（initialization）</p><p>JVM负责对类进行初始化，主要指静态成员</p></li></ol><h2 id="反射爆破"><a href="#反射爆破" class="headerlink" title="反射爆破"></a>反射爆破</h2><p>通过setAccessible(true)可以访问private暴力破解，破坏封装性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA反射&quot;&gt;&lt;a href=&quot;#JAVA反射&quot; class=&quot;headerlink&quot; title=&quot;JAVA反射&quot;&gt;&lt;/a&gt;JAVA反射&lt;/h1&gt;&lt;h2 id=&quot;开闭原则（OCP）&quot;&gt;&lt;a href=&quot;#开闭原则（OCP）&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式（Group Of Four 23）【待补充】</title>
    <link href="https://rockspeechcoder.github.io/2021/10/12/java-she-ji-mo-shi/"/>
    <id>https://rockspeechcoder.github.io/2021/10/12/java-she-ji-mo-shi/</id>
    <published>2021-10-12T08:24:43.000Z</published>
    <updated>2022-07-30T08:25:05.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式（Group-Of-Four-23）【待补充】"><a href="#设计模式（Group-Of-Four-23）【待补充】" class="headerlink" title="设计模式（Group Of Four 23）【待补充】"></a>设计模式（Group Of Four 23）【待补充】</h1><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ul><li><p>创建者模式</p><p>单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式</p></li><li><p>结构型模式</p><p>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</p></li><li><p>行为型模式</p><p>模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式</p></li></ul><h2 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h2><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 - Singleton"></a>单例模式 - Singleton</h3><ol><li><p>作用：保证一个类只有一个实例对象，并且提供一个访问该实例的全局访问点（方法）</p></li><li><p>应用场景：Spring中的每个bean；数据库连接池的设计；windows任务管理器；Windows回收站</p></li><li><p>优点：</p><ul><li><p>只生成一个实例，减少了系统性能开销。当一个对象的产生需要比较多的资源时，则在应用启动时产生一个单例对象，然后永久存在内存中</p></li><li><p>在系统设置全局访问点，优化环共享资源访问</p></li></ul></li><li><p>常见的实现方式</p><ul><li><p>饿汉式（线程安全、调用效率高。但是，不能延时加载）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    饿汉式单例实现：    1. 私有化构造器    2. 提供一个私有的static变量，存放唯一对象    3. 提供开放的方法访问对象* *&#x2F;public class SingletonDemo1 &#123;    &#x2F;&#x2F; 类初始化时。立即加载这个对象。存在问题：如果不调用getInstance()则会造成资源浪费    private static &#x2F;*final*&#x2F; SingletonDemo1 instance &#x3D; new SingletonDemo1();    private SingletonDemo1()&#123;    &#125;    &#x2F;&#x2F; static变量在类加载时初始化,不会发生并发访问的问题    public static &#x2F;*synchronized*&#x2F; SingletonDemo1 getInstance()&#123;        return instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>懒汉式（线程安全、调用效率不高。但是，能延时加载）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    懒汉式单例实现：    1. 提供一个私有的不初始化static变量，    2. 私有化构造器    3. 调用getInstance时new一个对象* *&#x2F;public class SingletonDemo2 &#123;    &#x2F;&#x2F; 延迟加载    private static SingletonDemo2 instance;    private SingletonDemo2()&#123;    &#125;    &#x2F;&#x2F;每次调用getInstance()都要同步，并发效率低    public static synchronized SingletonDemo2 getInstance()&#123;        if(instance &#x3D;&#x3D; null)&#123;            instance &#x3D; new SingletonDemo2();        &#125;        return instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双重检测锁式（JVM底层内部的原因，不建议使用）</p></li><li><p>静态内部类式（线程安全、调用效率高。能延时加载）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    静态内部类单例实现：    1. 私有化构造器    2. 创建静态内部类，在其中提供一个私有的static变量，存放唯一对象    3. 提供开放的方法访问对象* *&#x2F;public class SingletonDemo3 &#123;    &#x2F;&#x2F; 外部类没有static属性，则不会立即加载对象，也不会加载静态内部类    private static class SingletonClassInstance&#123;        &#x2F;&#x2F; 调用时加载静态内部类，加载类时天然线程安全。instance是static final修饰，保证内存中只有一个实例存在并且不能被修改        private static final SingletonDemo3 instance &#x3D; new SingletonDemo3();    &#125;    private SingletonDemo3()&#123;    &#125;    public static SingletonDemo3 getInstance()&#123;        return SingletonClassInstance.instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>枚举单例（线程安全、调用效率高。但是，不能延时加载。避免通过反射和序列化产生的漏洞）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    枚举式单例实现：    1. 定义一个枚举的元素* *&#x2F;public enum SingletonDemo4 &#123;    &#x2F;&#x2F; 枚举类即单例模式。定义一个枚举的元素，代表一个实例    INSTANCE;    public void singletonOperation()&#123;        &#x2F;&#x2F; 对实例的操作    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>选用</p><p>单例对象 占用资源少，不需要延时加载：枚举式好于饿汉式</p><p>单例对象 占用资源大，需要延时加载：静态内部类式好于懒汉式</p></li><li><p>反射反序列化测试单例漏洞（枚举类型除外）</p><ul><li><p>反射</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;SingletonDemo1&gt; clazz &#x3D; (Class&lt;SingletonDemo1&gt;) Class.forName(&quot;SingletonDemo.ehan.SingletonDemo1&quot;);Constructor&lt;SingletonDemo1&gt; c &#x3D; clazz.getDeclaredConstructor(null);c.setAccessible(true);SingletonDemo1 a &#x3D;c.newInstance();SingletonDemo1 b &#x3D;c.newInstance();System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false,两个不同的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  解决：私有化构造器加入异常判断</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">private SingletonDemo1()&#123;    if(instance !&#x3D; null)&#123;        throw new RuntimeException();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>反序列化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; SingletonDemo1需要实现SerializableSingletonDemo1 a &#x3D; SingletonDemo1.getInstance();&#x2F;&#x2F; 序列化FileOutputStream fos &#x3D; new FileOutputStream(&quot;d:&#x2F;a.txt&quot;);ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);oos.writeObject(a);oos.close();fos.close();&#x2F;&#x2F; 反序列化ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;a.txt&quot;));SingletonDemo1 b &#x3D; (SingletonDemo1)ois.readObject();System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决：添加readResolve方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 反序列化时，返回单例对象private Object readResolve() throws ObjectStreamException&#123;return instance;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h3 id="工厂模式-Factory"><a href="#工厂模式-Factory" class="headerlink" title="工厂模式 - Factory"></a>工厂模式 - Factory</h3><ol><li><p>作用：实现了创建者和调用者的分离</p></li><li><p>面向对象设计的基本原则：</p><ul><li>OCP开闭原则（open-closed principle）：一个软件的实体应该对扩展开放，对修改关闭</li><li>DIP依赖倒转原则（dependence inversionprinciple）：针对接口编程，不要针对实现编程</li><li>LOD迪米特原则（Law of Demeter）：只与你直接的朋友通信，而避免与陌生人通信</li></ul></li><li><p>应用场景：Calender的getInstance方法；JDBC中connection对象的获取</p></li><li><p>实现方式</p><ul><li><p>简单工厂模式（静态工厂模式）</p><p>描述：工厂类一般使用静态方法，通过接收的参数不同来返回不同的对象实例</p><p>问题：对于增加新产品，不修改代码的话无法扩展（不满足OCP）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestObjectSimpleFactory &#123;    public static TestObject createTestObject(String type)&#123;        if(type.equals(&quot;one&quot;))&#123;            return new ChildObjectOne();        &#125; else if(type.equals(&quot;two&quot;)) &#123;            return new ChildObjectTwo();        &#125;        return null;    &#125;&#125;public class client &#123;    public static void main(String[] args) &#123;        TestObject a &#x3D; TestObjectSimpleFactory.createTestObject(&quot;one&quot;);        TestObject b &#x3D; TestObjectSimpleFactory.createTestObject(&quot;two&quot;);        a.run();        b.run();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>工厂方法模式</p><p>描述：简单工厂模式只有一个工厂类，工厂方法模式有一组实现了相同接口的工厂类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface TestObjectMethodFactory &#123;    TestObject createTestObject();&#125;public class ChildObjectOneFactory implements TestObjectMethodFactory &#123;    @Override    public TestObject createTestObject  () &#123;        return new ChildObjectOne();    &#125;&#125;public class ChildObjectTwoFactory implements TestObjectMethodFactory &#123;    @Override    public TestObject createTestObject  () &#123;        return new ChildObjectTwo();    &#125;&#125;public static void main(String[] args) &#123;    TestObject a &#x3D; new ChildObjectOneFactory().createTestObject();    TestObject b &#x3D; new ChildObjectTwoFactory().createTestObject();    a.run();    b.run();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>抽象工厂模式</p><p>描述：用来生产不同产品族的全部产品。是工厂方法模式的升级版本。提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p>问题：对于增加新的产品，无能为力。支持增加产品族</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface TestObjectOne &#123;    public void runOne();    public void runTwo();&#125;public class TestObjectOneHigher implements TestObjectOne &#123;    @Override    public void runOne() &#123;        System.out.println(&quot;TestObjectOneHigher runOne&quot;);    &#125;    @Override    public void runTwo() &#123;        System.out.println(&quot;TestObjectOneHigher runTwo&quot;);    &#125;&#125;public class TestObjectOneLower implements TestObjectOne &#123;    @Override    public void runOne() &#123;        System.out.println(&quot;TestObjectOneLower runOne&quot;);    &#125;    @Override    public void runTwo() &#123;        System.out.println(&quot;TestObjectOneLower runTwo&quot;);    &#125;&#125;public interface TestObjectTwo &#123;    public void runOne();    public void runTwo();&#125;public class TestObjectTwoHigher implements TestObjectTwo &#123;    @Override    public void runOne() &#123;        System.out.println(&quot;TestObjectTwoHigher runOne&quot;);    &#125;    @Override    public void runTwo() &#123;        System.out.println(&quot;TestObjectTwoHigher runTwo&quot;);    &#125;&#125;public class TestObjectTwoLower implements TestObjectTwo &#123;    @Override    public void runOne() &#123;        System.out.println(&quot;TestObjectTwo runOne&quot;);    &#125;    @Override    public void runTwo() &#123;        System.out.println(&quot;TestObjectTwo runTwo&quot;);    &#125;&#125;public interface TestAbstractFactory &#123;    TestObjectOne createTestObjectOne();    TestObjectTwo createTestObjectTwo();&#125;public class TestHigherFactory implements TestAbstractFactory &#123;    @Override    public TestObjectOne createTestObjectOne() &#123;        return new TestObjectOneHigher();    &#125;    @Override    public TestObjectTwo createTestObjectTwo() &#123;        return new TestObjectTwoHigher();    &#125;&#125;public class TestLowerFactory implements TestAbstractFactory&#123;    @Override    public TestObjectOne createTestObjectOne() &#123;        return new TestObjectOneLower();    &#125;    @Override    public TestObjectTwo createTestObjectTwo() &#123;        return new TestObjectTwoLower();    &#125;&#125;public class client &#123;    public static void main(String[] args) &#123;        TestAbstractFactory lowerFactory &#x3D; new TestLowerFactory();        TestAbstractFactory higherFactory &#x3D; new TestHigherFactory();        TestObjectOne a &#x3D; lowerFactory.createTestObjectOne();        TestObjectOne b &#x3D; higherFactory.createTestObjectOne();        a.runOne();        a.runTwo();        b.runOne();        b.runTwo();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>比较：</p><p>简单工厂模式：结构复杂度更低</p><p>工厂方法模式：代码复杂度更低</p><p>设计理论工厂方法模式更优，但一般选择简单工厂模式</p></li></ol><h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 - Builder"></a>建造者模式 - Builder</h3><ol><li><p>作用：实现了构建（Builder）和装配（Director）的解耦，从而构造出复杂的对象。实现了构建算法、装配算法的解耦，实现更好的复用。</p></li><li><p>应用场景：StringBuilder的append方法；SQL的preparedStatement；</p></li><li><p>实现：</p><pre class="line-numbers language-none"><code class="language-none">public class TestObject &#123;    private ComponentA componentA;    private ComponentB componentB;&#125;public class ComponentA &#123;    public ComponentA(String a)&#123;        this.a &#x3D; a;    &#125;    private String a;&#125;public class ComponentB &#123;    public ComponentB(String b)&#123;        this.b &#x3D; b;    &#125;    private String b;&#125;public interface TestObjectBuilder &#123;    ComponentA builderComponentA();    ComponentB builderComponentB();&#125;public class TestObjectBuilderImpl implements TestObjectBuilder&#123;    @Override    public ComponentA builderComponentA() &#123;        System.out.println(&quot;构建组件A&quot;);        return new ComponentA(&quot;组件A&quot;);    &#125;    @Override    public ComponentB builderComponentB() &#123;        System.out.println(&quot;构建组件B&quot;);        return new ComponentB(&quot;组件B&quot;);    &#125;&#125;public interface TestObjectDirector &#123;    TestObject directorTestObject();&#125;public class TestObjectDirectorImpl implements TestObjectDirector&#123;    private TestObjectBuilder builder;    public TestObjectDirectorImpl(TestObjectBuilder builder)&#123;        this.builder &#x3D; builder;    &#125;    @Override    public TestObject directorTestObject() &#123;        ComponentA a &#x3D; builder.builderComponentA();        ComponentB b &#x3D; builder.builderComponentB();        TestObject t &#x3D; new TestObject();        t.setComponentA(a);        t.setComponentB(b);        return t;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 - Prototype"></a>原型模式 - Prototype</h3><ol><li><p>作用：以某个对象为原型，复制出新的对象。新的对象具备原型对象的特点。解决产生一个对象需要繁琐的数据准备和访问权限的问题。一般和工厂方法模式一起使用</p></li><li><p>应用场景：Cloneable接口和clone方法</p></li><li><p>优点：效率高，避免了重新执行构造过程的步骤</p></li><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ShallowCloneObject implements Cloneable,Serializable&#123;    private String name;    private Date createTime;    public ShallowCloneObject(String name, Date createTime)&#123;        this.name &#x3D; name;        this.createTime &#x3D; createTime;    &#125;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;&#125;public class DeepCloneObject implements Cloneable&#123;    private String name;    private Date createTime;    public DeepCloneObject(String name, Date createTime)&#123;        this.name &#x3D; name;        this.createTime &#x3D; createTime;    &#125;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        Object object &#x3D; super.clone();        DeepCloneObject deepCloneObject &#x3D; (DeepCloneObject) object;        deepCloneObject.createTime &#x3D; ((Date) this.createTime.clone());        return object;    &#125;&#125;public static void main(String[] args) throws CloneNotSupportedException &#123;    &#x2F;&#x2F; 浅克隆，克隆对象的时间字段与原型对象指向同一个date，修改后互相影响    System.out.println(&quot;浅克隆--------------------------&quot;);    Date date1 &#x3D; new Date();    ShallowCloneObject s &#x3D; new ShallowCloneObject(&quot;原型对象&quot;,date1);    System.out.println(s.getName() + s.getCreateTime());    ShallowCloneObject shallowCloneObject &#x3D; (ShallowCloneObject)s.clone();    System.out.println(shallowCloneObject.getName() + shallowCloneObject.getCreateTime());    shallowCloneObject.setName(&quot;克隆对象&quot;);    date1.setTime(1000000000000L);    System.out.println(s.getName() + s.getCreateTime());    System.out.println(shallowCloneObject.getName() + shallowCloneObject.getCreateTime());    &#x2F;&#x2F; 深复制    System.out.println(&quot;深复制--------------------------&quot;);    Date date2 &#x3D; new Date();    DeepCloneObject d &#x3D; new DeepCloneObject(&quot;原型对象&quot;,date2);    System.out.println(d.getName() + d.getCreateTime());    DeepCloneObject deepCloneObject &#x3D; (DeepCloneObject)d.clone();    System.out.println(deepCloneObject.getName() + deepCloneObject.getCreateTime());    deepCloneObject.setName(&quot;克隆对象&quot;);    date2.setTime(1000000000000L);    System.out.println(d.getName() + d.getCreateTime());    System.out.println(deepCloneObject.getName() + deepCloneObject.getCreateTime());&#125;public static void main(String[] args) throws IOException, ClassNotFoundException &#123;    &#x2F;&#x2F; 使用序列化和反序列化    Date date &#x3D; new Date();    ShallowCloneObject s &#x3D; new ShallowCloneObject(&quot;原型对象&quot;,date);    ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();    ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);    oos.writeObject(s);    byte[] bytes &#x3D; bos.toByteArray();    ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bytes);    ObjectInputStream ois &#x3D; new ObjectInputStream(bis);    ShallowCloneObject deepCloneBySerialization &#x3D; (ShallowCloneObject)ois.readObject();    System.out.println(s.getName() + s.getCreateTime());    System.out.println(deepCloneBySerialization.getName() + deepCloneBySerialization.getCreateTime());    date.setTime(12121212121212L);    System.out.println(s.getName() + s.getCreateTime());    System.out.println(deepCloneBySerialization.getName() + deepCloneBySerialization.getCreateTime());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式-Adapter"></a>适配器模式-Adapter</h3><ol><li><p>描述：将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的类可以一起工作</p></li><li><p>应用场景：旧系统升级改造；java.io.InputStreamReader(InputStream)；java.io.OutputStreamWriter(OutputStream);</p></li><li><p>角色：</p><ul><li>被适配的类 - Adaptee：持有既定方法，需要适配</li><li>适配器 - Adapter：使用Adaptee的方法满足Target需求</li><li>目标类 - Target：定义所需的方法</li></ul></li><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** 被适配的类* *&#x2F;public class Adaptee &#123;    public void request()&#123;        System.out.println(&quot;被适配的类提供客户端需要的功能&quot;);    &#125;&#125;&#x2F;** 适配器(类适配器方式)* *&#x2F;public class Adapter extends Adaptee implements Target&#123;    @Override    public void handleRequest() &#123;        super.request();    &#125;&#125;&#x2F;* * 适配器(对象适配器方式) * *&#x2F;public class Adapter2 implements Target&#123;    private Adaptee adaptee;    public Adapter2(Adaptee a)&#123;        super();        this.adaptee &#x3D; a;    &#125;    @Override    public void handleRequest() &#123;        adaptee.request();    &#125;&#125;public interface Target &#123;    void handleRequest();&#125;public class Client &#123;    public void test(Target t)&#123;        t.handleRequest();    &#125;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 1. 类适配器        Client c1 &#x3D; new Client();        Target t1 &#x3D; new Adapter();        c1.test(t1);        &#x2F;&#x2F; 2. 对象组合适配器        Client c2 &#x3D; new Client();        Adaptee a &#x3D; new Adaptee();        Target t2 &#x3D; new Adapter2(a);        c2.test(t2);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 - Proxy"></a>代理模式 - Proxy</h3><ol><li><p>描述：通过代理控制对对象的访问，在调用某个对象方法前做前置处理，调用过后做后置处理。将统一的流程控制放在代理类中处理</p></li><li><p>应用场景：数据库连接池关闭处理；mybatis实现拦截器插件</p><ul><li>安全代理：屏蔽对真实角色的直接访问</li><li>远程代理：通过代理类处理远程方法调用（RMI）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li></ul></li><li><p>角色：</p><ul><li>抽象的角色 - Subject：定义了使Proxy和RealSubject具有一致性的接口</li><li>代理人 - Proxy：实现了Subject接口，尽量代替真实角色处理请求，处理不了再转给RealSubject</li><li>真实角色 - RealSubject：实现了Subject接口，必要时处理请求</li></ul></li><li><p>实现方式：</p><ul><li><p>静态代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface AbstractRole &#123;    void step1();    void step2();    void step3();&#125;public class RealRole implements AbstractRole&#123;    @Override    public void step1() &#123;        System.out.println(&quot;真实角色-步骤1&quot;);    &#125;    @Override    public void step2() &#123;        System.out.println(&quot;真实角色-步骤2&quot;);    &#125;    @Override    public void step3() &#123;        System.out.println(&quot;真实角色-步骤3,代理角色没有的方法&quot;);    &#125;&#125;public class ProxyRole implements AbstractRole&#123;    AbstractRole abstractRole;    public ProxyRole(AbstractRole abstractRole)&#123;        super();        this.abstractRole &#x3D; abstractRole;    &#125;    @Override    public void step1() &#123;        System.out.println(&quot;代理角色-步骤1,代替真实角色执行&quot;);    &#125;    @Override    public void step2() &#123;        System.out.println(&quot;代理角色-步骤2,代替真实角色执行&quot;);    &#125;    @Override    public void step3() &#123;        abstractRole.step3();    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        AbstractRole realRole &#x3D; new RealRole();        AbstractRole proxyRole &#x3D; new ProxyRole(realRole);        proxyRole.step1();        proxyRole.step2();        proxyRole.step3();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>动态代理（JDK实现）</p><p>java.lang.reflect.Proxy：动态生成代理类和对象</p><p>java.lang.reflect.InvocationHandler：处理器接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface AbstractRole &#123;    void step1();    void step2();    void step3();&#125;public class RealRole implements AbstractRole &#123;    @Override    public void step1() &#123;        System.out.println(&quot;真实角色-步骤1&quot;);    &#125;    @Override    public void step2() &#123;        System.out.println(&quot;真实角色-步骤2&quot;);    &#125;    @Override    public void step3() &#123;        System.out.println(&quot;真实角色-步骤3,代理角色没有的方法&quot;);    &#125;&#125;public class AbstractRoleHandler implements InvocationHandler &#123;    AbstractRole abstractRole;    public AbstractRoleHandler(AbstractRole abstractRole)&#123;        this.abstractRole &#x3D; abstractRole;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;invoke流程控制&quot;);        Object object &#x3D; null;        System.out.println(&quot;真实角色方法执行前&quot;);        if(method.getName().equals(&quot;step3&quot;))&#123;            object &#x3D; method.invoke(abstractRole,args);        &#125;        System.out.println(&quot;真实角色方法执行后&quot;);        return object;    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        AbstractRole realRole &#x3D; new RealRole();        AbstractRoleHandler handler &#x3D; new AbstractRoleHandler(realRole);        AbstractRole proxyRole&#x3D; (AbstractRole)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;AbstractRole.class&#125;,handler);        proxyRole.step3();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>比较：</p><p>动态代理的优点：抽象角色中声明的所有方法都被转移到调用处理器一个集中的方法中处理，可以更加灵活和统一地处理众多的方法</p></li></ol><h3 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 - Bridge"></a>桥接模式 - Bridge</h3><ol><li><p>描述：处理多层继承结构，处理多个维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立地扩展</p></li><li><p>应用场景：JDBC驱动程序</p></li><li><p>角色：</p></li><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Veidoo1 &#123;    void veidoo1Method();&#125;public class Veidoo2 &#123;    protected Veidoo1 veidoo1;    public Veidoo2(Veidoo1 veidoo1)&#123;        this.veidoo1 &#x3D; veidoo1;    &#125;    public void veidoo2Method()&#123;        veidoo1.veidoo1Method();    &#125;&#125;public class Veidoo1Classify1 implements Veidoo1&#123;    @Override    public void veidoo1Method() &#123;        System.out.println(&quot;#####################&quot;);        System.out.println(&quot;Veidoo1Classify1&quot;);    &#125;&#125;public class Veidoo1Classify2 implements Veidoo1&#123;    @Override    public void veidoo1Method() &#123;        System.out.println(&quot;#####################&quot;);        System.out.println(&quot;Veidoo1Classify2&quot;);    &#125;&#125;public class Veidoo2Classify1 extends Veidoo2&#123;    public Veidoo2Classify1(Veidoo1 veidoo1)&#123;        super(veidoo1);    &#125;    @Override    public void veidoo2Method()&#123;        super.veidoo2Method();        System.out.println(&quot;Veidoo2Classify1&quot;);    &#125;&#125;public class Veidoo2Classify2 extends Veidoo2&#123;    public Veidoo2Classify2(Veidoo1 veidoo1)&#123;        super(veidoo1);    &#125;    @Override    public void veidoo2Method()&#123;        super.veidoo2Method();        System.out.println(&quot;Veidoo2Classify2&quot;);    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        Veidoo2 o1 &#x3D; new Veidoo2Classify1(new Veidoo1Classify1());        Veidoo2 o2 &#x3D; new Veidoo2Classify2(new Veidoo1Classify1());        Veidoo2 o3 &#x3D; new Veidoo2Classify1(new Veidoo1Classify2());        Veidoo2 o4 &#x3D; new Veidoo2Classify2(new Veidoo1Classify2());        o1.veidoo2Method();        o2.veidoo2Method();        o3.veidoo2Method();        o4.veidoo2Method();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 - Composite"></a>组合模式 - Composite</h3><ol><li><p>描述：把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象</p></li><li><p>角色：</p><ul><li>抽象构件角色 - Component：定义了叶子和容器构件的共同点</li><li>叶子构件角色 - Leaf：无子节点</li><li>容器构件角色 - Composite：有容器特征，可以包含子节点</li></ul></li><li><p>应用场景：操作系统的资源管理器；xml文件解析；oa组织树</p></li><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Component &#123;    void operation();&#125;public class CompositeImpl implements Component&#123;    private String name;    private List&lt;Component&gt; list &#x3D; new ArrayList&lt;&gt;();    public CompositeImpl(String name) &#123;        this.name &#x3D; name;    &#125;    public void add(Component component)&#123;        list.add(component);    &#125;    public void remove(Component component)&#123;        list.remove(component);    &#125;    public Component getChild(int index)&#123;        return list.get(index);    &#125;    @Override    public void operation() &#123;        System.out.println(&quot;CompositeImpl&quot;+name);        for(Component c:list)&#123;            c.operation();        &#125;    &#125;&#125;public class LeafOneImpl implements Component&#123;    private String name;    public LeafOneImpl(String name) &#123;        this.name &#x3D; name;    &#125;    @Override    public void operation() &#123;        System.out.println(&quot;ComponentImpl &quot; + name);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;&#125;public class LeafTwoImpl implements Component&#123;    private String name;    public LeafTwoImpl(String name) &#123;        this.name &#x3D; name;    &#125;    @Override    public void operation() &#123;        System.out.println(&quot;ComponentTwoImpl &quot; + name);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        Component c1 &#x3D; new LeafOneImpl(&quot;叶子节点1&quot;);        Component c2 &#x3D; new LeafTwoImpl(&quot;叶子节点2&quot;);        CompositeImpl c3 &#x3D; new CompositeImpl(&quot;容器节点&quot;);        CompositeImpl c4 &#x3D; new CompositeImpl(&quot;子容器节点&quot;);        c3.add(c1);        c4.add(c2);        c2.operation();        c3.operation();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 - Decorator"></a>装饰模式 - Decorator</h3><ol><li><p>描述：动态地为一个对象增加新的功能，使用对象的关联关系代替继承关系，无需通过继承增加子类就能扩展对象的新功能。同时避免类型体系的快速膨胀。</p></li><li><p>角色：</p><ul><li>抽象构件角色 - Component：真实对象和装饰对象具有相同的接口</li><li>具体构件角色 - ConcreteComponent：真实对象</li><li>装饰角色 - Decorator：接受所有客户端的请求，并把请求转发给真实的对象。在调用真实对象前后增加新的功能</li><li>具体装饰角色 - ConcreteDecorator：负责给构件对象增加新功能</li></ul></li><li><p>应用场景：io流；</p></li><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Component &#123;    void run();&#125;public class ConcreteComponent implements Component&#123;    @Override    public void run() &#123;        System.out.println(&quot;ConcreteComponent run&quot;);    &#125;&#125;public class Decorator implements Component&#123;    private Component component;    public Decorator(Component component)&#123;        this.component &#x3D; component;    &#125;    @Override    public void run() &#123;        System.out.println(&quot;Decorator run&quot;);        component.run();    &#125;&#125;public class ConcreteDecorator extends Decorator&#123;    public ConcreteDecorator(Component component) &#123;        super(component);        addMethod();    &#125;    public void addMethod()&#123;        System.out.println(&quot;ConcreteDecorator addMethod&quot;);    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        ConcreteComponent concreteComponent &#x3D; new ConcreteComponent();        concreteComponent.run();        &#x2F;&#x2F;增加新功能        ConcreteDecorator concreteDecorator &#x3D; new ConcreteDecorator(concreteComponent);        concreteDecorator.addMethod();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式 -"></a>外观模式 -</h3><ol><li>描述：为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式（Group-Of-Four-23）【待补充】&quot;&gt;&lt;a href=&quot;#设计模式（Group-Of-Four-23）【待补充】&quot; class=&quot;headerlink&quot; title=&quot;设计模式（Group Of Four 23）【待补充】&quot;&gt;&lt;/a&gt;设计模式（</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://rockspeechcoder.github.io/2021/08/23/maven/"/>
    <id>https://rockspeechcoder.github.io/2021/08/23/maven/</id>
    <published>2021-08-23T13:11:31.000Z</published>
    <updated>2022-08-25T11:45:13.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>构件和依赖工具</p><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><img src="/2021/08/23/maven/image-1.png" class=""><h2 id="配置阿里云镜像"><a href="#配置阿里云镜像" class="headerlink" title="配置阿里云镜像"></a>配置阿里云镜像</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>AliRepo-aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Mirror Name for the Alirepo.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>https://maven.aliyun.com/repository/public<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MAVEN使用"><a href="#MAVEN使用" class="headerlink" title="MAVEN使用"></a>MAVEN使用</h2><h3 id="1-定位maven"><a href="#1-定位maven" class="headerlink" title="1. 定位maven"></a>1. 定位maven</h3><ul><li>groupId：公司或组织项目的id，域名倒序</li><li>artifactId：一个模块id，maven工程的工程名</li><li>version：版本号，SHAPSHOT-迭代过程中的快照版本；RELEASE-正式版本</li></ul><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><ul><li>创建项目 <code>mvn archetype:generate</code></li><li>删除target目录<code>mvn clean </code></li><li>编译 <code>mvn compile</code> (<code>mvn test-compile</code> 测试编译)</li><li>测试mvn test</li><li>打包mvn package</li><li>安装jar包到本地仓库 mvn install</li><li></li></ul><h3 id="3-pom-xml-项目对象模型"><a href="#3-pom-xml-项目对象模型" class="headerlink" title="3.pom.xml-项目对象模型"></a>3.pom.xml-项目对象模型</h3><p>​    project object model</p><ul><li>根标签project，对当前工程进行配置</li><li>modelVersion:代表pom.xml所采用的的标签结构</li><li>groupId</li><li>artifactId</li><li>version</li><li>packaging：打包方式<ul><li>默认jar包，即Java工程；</li><li>war包，即web工程；</li><li>pom：用来管理其他工程的工程</li></ul></li><li>properties：定义属性值</li><li>project.build.sourceEncoding：构建过程中读取源码时使用的字符集</li><li>dependencies：配置多个依赖信息</li><li>dependency：配置具体依赖信息</li><li>scope：当前依赖范围</li></ul><h3 id="4-目录结构"><a href="#4-目录结构" class="headerlink" title="4. 目录结构"></a>4. 目录结构</h3>   <img src="/2021/08/23/maven/image-2.png" class=""><h3 id="5-依赖范围"><a href="#5-依赖范围" class="headerlink" title="5. 依赖范围"></a>5. 依赖范围</h3><p>可选值</p><ul><li><p>compile（默认）</p><p>通常使用的第三方框架的jar包，这样在实际运行时主体功能中真正用到的jar包。可以部署到服务器。</p></li><li><p>test</p><p>main目录下无效；部署到服务器无效。</p></li><li><p>provided</p><p>部署到服务器无效。</p></li><li><p>system</p></li><li><p>runtime</p></li><li><p>import</p></li></ul><h3 id="6-依赖传递"><a href="#6-依赖传递" class="headerlink" title="6. 依赖传递"></a>6. 依赖传递</h3><p>​    A依赖B，B依赖C，A是否可以使用C，取决于：</p><ul><li>如果B依赖C是compile就传递过去</li><li>如果B依赖C是test/provided就传递不过去</li></ul><h3 id="7-依赖排除"><a href="#7-依赖排除" class="headerlink" title="7. 依赖排除"></a>7. 依赖排除</h3><p>​    A依赖B，B依赖C，A可以使用C但需要排除掉的时候（解决jar包冲突）</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-继承"><a href="#8-继承" class="headerlink" title="8. 继承"></a>8. 继承</h3><p>   A工程继承B工程，则A的pom配置继承B的pom。</p><h3 id="9-聚合"><a href="#9-聚合" class="headerlink" title="9. 聚合"></a>9. 聚合</h3>   <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Maven&quot;&gt;&lt;a href=&quot;#Maven&quot; class=&quot;headerlink&quot; title=&quot;Maven&quot;&gt;&lt;/a&gt;Maven&lt;/h1&gt;&lt;p&gt;构件和依赖工具&lt;/p&gt;
&lt;h2 id=&quot;工作机制&quot;&gt;&lt;a href=&quot;#工作机制&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA项目分层</title>
    <link href="https://rockspeechcoder.github.io/2021/07/13/java-xiang-mu-fen-ceng/"/>
    <id>https://rockspeechcoder.github.io/2021/07/13/java-xiang-mu-fen-ceng/</id>
    <published>2021-07-13T11:19:35.000Z</published>
    <updated>2022-07-27T17:05:59.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考阿里规范，优秀的-Java-项目代码该如何分层？"><a href="#参考阿里规范，优秀的-Java-项目代码该如何分层？" class="headerlink" title="参考阿里规范，优秀的 Java 项目代码该如何分层？"></a>参考阿里规范，优秀的 Java 项目代码该如何分层？</h1><p>来源：<a href="https://www.cnblogs.com/bainannan/p/14418277.html">https://www.cnblogs.com/bainannan/p/14418277.html</a></p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>说起应用分层，大部分人都会认为这个不是很简单嘛 就controller，service, mapper三层。看起来简单，很多人其实并没有把他们职责划分开，在很多代码中, controller做的逻辑比service还多, service往往当成透传了。<br>这其实是很多人开发代码都没有注意到的地方，反正功能也能用，至于放哪无所谓呗。这样往往造成后面代码无法复用，层级关系混乱，对后续代码的维护非常麻烦。<br>的确在这些人眼中分层只是一个形式，前辈们的代码这么写的，其他项目代码这么写的，那么我也这么跟着写。<br>但是在真正的团队开发中每个人的习惯都不同，写出来的代码必然带着自己的标签，有的人习惯controller写大量的业务逻辑，有的人习惯在service中之间调用远程服务，这样就导致了每个人的开发代码风格完全不同。<br>后续其他人修改的时候，一看，我靠这个人写的代码和我平常的习惯完全不同，修改的时候到底是按着自己以前的习惯改，还是跟着前辈们走，这又是个艰难的选择，选择一旦有偏差，你的后辈又维护你的代码的时候，恐怕就要骂人了。<br>所以一个好的应用分层需要具备以下几点:</p><ul><li>方便后续代码进行维护扩展。</li><li>分层的效果需要让整个团队都接受</li><li>各个层职责边界清晰<h3 id="2-如何进行分层"><a href="#2-如何进行分层" class="headerlink" title="2.如何进行分层"></a>2.如何进行分层</h3><h5 id="2-1阿里规范"><a href="#2-1阿里规范" class="headerlink" title="2.1阿里规范"></a>2.1阿里规范</h5>在阿里的编码规范中约束的分层如下:<img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_1.png" class="">开放接口层: 可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。<br>终端显示层: 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。<br>Web 层: 主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。<br>Service 层: 相对具体的业务逻辑服务层。<br>Manager 层: 通用业务处理层，它有如下特征:1. 对第三方平台封装的层，预处理返回结果及转化异常信息;2. 对Service层通用能力的下沉，如缓存方案、中间件通用处理;3. 与DAO层交互，对多个DAO的组合复用。<br>DAO 层: 数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。<br>阿里巴巴规约中的分层比较清晰简单明了，但是描述得还是过于简单了，以及service层和manager层有很多同学还是有点分不清楚之间的关系，就导致了很多项目中根本没有Manager层的存在。下面介绍一下具体业务中应该如何实现分层<h5 id="2-2优化分层"><a href="#2-2优化分层" class="headerlink" title="2.2优化分层"></a>2.2优化分层</h5>从我们的业务开发中总结了一个较为的理想模型,这里要先说明一下由于我们的rpc框架选用的是thrift可能会比其他的一些rpc框架例如dubbo会多出一层,作用和controller层类似<img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_2.png" class=""></li></ul><p>1.最上层controller和TService是我们阿里分层规范里面的第一层: 轻业务逻辑，参数校验，异常兜底。通常这种接口可以轻易更换接口类型,所以业务逻辑必须要轻，甚至不做具体逻辑。<br>2.Service：业务层，复用性较低，这里推荐每一个controller方法都得对应一个service,不要把业务编排放在controller中去做，为什么呢？<br>如果我们把业务编排放在controller层去做的话，如果以后我们要接入thrift,我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层这个代码都得重新复制一份如下图所示:</p><img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_3.png" class=""><p>这样大量的重复工作必定会导致我们开发效率下降，所以我们需要把业务编排逻辑都得放进service中去做:</p><img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_4.png" class=""><p>3.Mannager：可复用逻辑层。这里的Mannager可以是单个服务的，比如我们的cache,mq等等，当然也可以是复合的，当你需要调用多个Mannager的时候，这个可以合为一个Mannager，比如逻辑上的连表查询等。如果是httpMannager或rpcMannager需要在这一层做一些数据转换<br>4.DAO：数据库访问层。主要负责“操作数据库的某张表，映射到某个java对象”，dao应该只允许自己的Service访问，其他Service要访问我的数据必须通过对应的Service。</p><h3 id="3-分层领域模型的转换"><a href="#3-分层领域模型的转换" class="headerlink" title="3.分层领域模型的转换"></a>3.分层领域模型的转换</h3><p>在阿里巴巴编码规约中列举了下面几个领域模型规约:</p><ul><li>DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。</li><li>BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。</li><li>AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。</li></ul><p>每一个层基本都自己对应的领域模型，这样就导致了有些人过于追求每一层都是用自己的领域模型，这样就导致了一个对象可能会出现3次甚至4次转换在一次请求中，当返回的时候同样也会出现3-4次转换，这样有可能一次完整的请求-返回会出现很多次对象转换。如果在开发中真的按照这么来，恐怕就别写其他的了，一天就光写这个重复无用的逻辑算了吧。<br>所以我们得采取一个折中的方案:</p><ol><li>允许Service/Manager可以操作数据领域模型，对于这个层级来说，本来自己做的工作也是做的是业务逻辑处理和数据组装。</li><li>Controller/TService层的领域模型不允许传入DAO层，这样就不符合职责划分了。</li><li>同理，不允许DAO层的数据传入到Controller/TService.</li></ol><img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_5.png" class=""><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>总的来说业务分层对于代码规范是比较重要，决定着以后的代码是否可复用，是否职责清晰，边界清晰。<br>当然这种分层其实见仁见智, 团队中的所有人的分层习惯也不同，所以很难权衡出一个标准的准则，总的来说只要满足职责逻辑清晰，后续维护容易，就是好的分层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考阿里规范，优秀的-Java-项目代码该如何分层？&quot;&gt;&lt;a href=&quot;#参考阿里规范，优秀的-Java-项目代码该如何分层？&quot; class=&quot;headerlink&quot; title=&quot;参考阿里规范，优秀的 Java 项目代码该如何分层？&quot;&gt;&lt;/a&gt;参考阿里规范，优</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="https://rockspeechcoder.github.io/2021/05/02/springboot/"/>
    <id>https://rockspeechcoder.github.io/2021/05/02/springboot/</id>
    <published>2021-05-02T10:44:33.000Z</published>
    <updated>2022-10-13T14:56:42.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>   SpringBoot是整合Spring技术栈的一站式框架，SpringBoot是简化Spring技术栈的快速开发脚手架，能快速创建出生产级别的Spring应用。</p><h2 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h2><ul><li>Create stand-alone Spring applications</li><li>创建独立Spring应用</li><li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</li><li>内嵌web服务器</li><li>Provide opinionated ‘starter’ dependencies to simplify your build configuration</li><li>自动starter依赖，简化构建配置</li><li>Automatically configure Spring and 3rd party libraries whenever possible</li><li>自动配置Spring以及第三方功能</li><li>Provide production-ready features such as metrics, health checks, and externalized configuration</li><li>提供生产级别的监控、健康检查及外部化配置</li><li>Absolutely no code generation and no requirement for XML configuration</li><li>无代码生成、无需编写XML</li></ul><h2 id="3-创建maven工程"><a href="#3-创建maven工程" class="headerlink" title="3. 创建maven工程"></a>3. 创建maven工程</h2><ol><li><p>引入依赖</p> <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web场景启动器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>主程序类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 主程序类 * @SpringBootApplication：这是一个SpringBoot应用 *&#x2F;@SpringBootApplicationpublic class MainApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MainApplication.class,args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>简化部署打jar包</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="4-依赖管理与自动配置"><a href="#4-依赖管理与自动配置" class="headerlink" title="4. 依赖管理与自动配置"></a>4. 依赖管理与自动配置</h2><ol><li><p>依赖管理   </p><ul><li><p>父项目做依赖管理</p>   <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--spring-boot-starter-parent的父项目--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>开发导入starter场景启动器</p><ul><li>spring-boot-starter-* ： *就某种场景</li><li>只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</li><li>SpringBoot所有支持的场景<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a></li><li>*-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</li><li>所有场景启动器最底层的依赖<code>spring-boot-starter-parent</code></li></ul></li><li><p>无需关注版本号，自动版本仲裁</p><ul><li>引入依赖默认都可以不写版本</li><li>引入非版本仲裁的jar，要写版本号</li></ul></li><li><p>可以修改默认版本号</p>   <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mysql.version</span><span class="token punctuation">></span></span>5.1.43<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mysql.version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>自动配置</p><ul><li><p>自动配好Tomcat</p><ul><li>引入Tomcat依赖</li><li>配置Tomcat</li></ul></li><li><p>自动配好SpringMVC</p><ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）</li></ul></li><li><p>自动配好Web常见功能，如：字符编码问题</p><ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li><li><p>默认的包结构</p><ul><li>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</li><li>无需以前的包扫描配置</li><li>想要改变扫描路径，@SpringBootApplication(scanBasePackages=”包名”)或者@ComponentScan 指定扫描路径</li></ul></li><li><p>各种配置拥有默认值</p><ul><li>默认配置最终都是映射到某个类上，如：MultipartProperties</li><li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li></ul></li><li><p>按需加载所有自动配置项</p><ul><li>引入了哪些场景这个场景的自动配置才会开启</li><li>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</li></ul></li></ul></li></ol><h2 id="5-底层注解"><a href="#5-底层注解" class="headerlink" title="5. 底层注解"></a>5. 底层注解</h2><pre><code>1. @Configuration   - 配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的   - 配置类本身也是组件   - proxyBeanMethods：代理bean的方法      - Full：(proxyBeanMethods = true)【保证每个@Bean方法被调用多少次返回的对象都是单实例的】      - Lite：(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的对象都是新创建的】      - 组件依赖必须使用Full模式默认。其他默认是否Lite模式2. @Import  导入组件：给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名  <pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import(&#123;User.class, DBHelper.class&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>3. @Conditional  条件装配：满足Conditional指定的条件，则进行组件注入</code></pre><ol start="4"><li><p>@ImportResource</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ImportResource(&quot;classpath:beans.xml&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置绑定</p><p>Java读取到properties文件中的内容，并且把它封装到JavaBean中</p><ul><li><p>@Component + @ConfigurationProperties</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能 *&#x2F;@Component@ConfigurationProperties(prefix &#x3D; &quot;mycar&quot;)public class Car&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>@EnableConfigurationProperties + @ConfigurationProperties</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableConfigurationProperties(Car.class)&#x2F;&#x2F;1、开启Car配置绑定功能&#x2F;&#x2F;2、把这个Car这个组件自动注册到容器中public class MyConfig &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="6-自动配置原理"><a href="#6-自动配置原理" class="headerlink" title="6. 自动配置原理"></a>6. 自动配置原理</h2><p><strong>xxxxxAutoConfiguration —&gt; 组件  —&gt;</strong> <strong>xxxxProperties里面拿值  —-&gt; application.properties</strong></p><ul><li><p>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</p></li><li><p>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值，xxxxProperties里面拿。xxxProperties和配置文件进行了绑定</p></li><li><p>生效的配置类就会给容器中装配很多组件</p></li><li><p>只要容器中有这些组件，相当于这些功能就有了</p></li><li><p>定制化配置</p></li><li><ul><li>用户直接自己@Bean替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改。</li></ul></li><li></li></ul><ol><li><p>加载自动配置类</p><ul><li><p>@SpringBootConfiguration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p><ul><li><p>@AutoConfigurationPackage</p><p>@Import({AutoConfigurationPackages.Registrar.class})</p><p>利用Registrar导入一系列组件</p></li><li><p>@Import({AutoConfigurationImportSelector.class})</p><p>获取所有导入到容器中的配置类，从META-INF/spring.factories位置来加载一个文件。</p><pre><code>默认扫描我们当前系统里面所有jar包META-INF/spring.factories位置的文件</code></pre></li></ul></li></ul></li><li><p>按照条件装配规则（@Conditional），最终会按需配置。</p></li><li><p>修改默认配置，以用户修改的优先</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@ConditionalOnBean(MultipartResolver.class)  &#x2F;&#x2F;容器中有这个类型组件@ConditionalOnMissingBean(name &#x3D; DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) &#x2F;&#x2F;容器中没有这个名字 multipartResolver 的组件public MultipartResolver multipartResolver(MultipartResolver resolver) &#123;    &#x2F;&#x2F;给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。    &#x2F;&#x2F;SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范    &#x2F;&#x2F; Detect if the user has created a MultipartResolver but named it incorrectly    return resolver;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="7-Lombok"><a href="#7-Lombok" class="headerlink" title="7. Lombok"></a>7. Lombok</h2><ol><li><p>依赖+插件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>@Data</p><p>生成set/get</p></li><li><p>@ToString</p></li><li><p>@AllArgsConstructor</p><p>全参构造器</p></li><li><p>@NoArgsConstructor</p><p>无参构造器</p></li><li><p>@EqualsAndHashCode</p></li><li><p>@Slf4j</p><p>log.info</p></li></ol><h2 id="8-Web开发"><a href="#8-Web开发" class="headerlink" title="8. Web开发"></a>8. Web开发</h2><ol><li><p>Rest原理（表单提交要使用REST的时候）</p><ul><li><p>表单提交会带上**_method=PUT**</p></li><li><p><strong>请求过来被</strong>HiddenHttpMethodFilter拦截</p><ul><li><p>请求是否正常，并且是POST</p></li><li><p>获取到**_method**的值。</p><ul><li>兼容以下请求；<strong>PUT</strong>.<strong>DELETE</strong>.<strong>PATCH</strong></li><li><strong>原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。</strong></li><li><strong>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用****requesWrapper的。</strong></li></ul></li></ul></li></ul></li><li><p>参数处理原理</p><ul><li>HandlerMapping中找到能处理请求的Handler（Controller.method()）</li><li>为当前Handler 找一个适配器 HandlerAdapter； <strong>RequestMappingHandlerAdapter</strong></li><li>适配器执行目标方法并确定方法参数的每一个值</li></ul></li></ol><h2 id="9-SpringBoot启动过程"><a href="#9-SpringBoot启动过程" class="headerlink" title="9.SpringBoot启动过程"></a>9.SpringBoot启动过程</h2><ul><li><p>创建 <strong>SpringApplication</strong></p></li><li><ul><li>保存一些信息。</li><li>判定当前应用的类型。ClassUtils。Servlet</li><li><strong>bootstrappers****：初始启动引导器（</strong>List<Bootstrapper><strong>）：去spring.factories文件中找</strong> org.springframework.boot.<strong>Bootstrapper</strong></li><li>找 <strong>ApplicationContextInitializer</strong>；去<strong>spring.factories****找</strong> <strong>ApplicationContextInitializer</strong></li></ul></li><li><ul><li><ul><li>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; <strong>initializers</strong></li></ul></li></ul></li><li><ul><li><strong>找</strong> <strong>ApplicationListener  ；应用监听器。</strong>去<strong>spring.factories****找</strong> <strong>ApplicationListener</strong></li></ul></li><li><ul><li><ul><li>List&lt;ApplicationListener&lt;?&gt;&gt; <strong>listeners</strong></li></ul></li></ul></li><li><p>运行 <strong>SpringApplication</strong></p></li><li><ul><li><strong>StopWatch</strong></li><li><strong>记录应用的启动时间</strong></li><li><strong>创建引导上下文（Context环境）****createBootstrapContext()</strong></li></ul></li><li><ul><li><ul><li>获取到所有之前的 <strong>bootstrappers 挨个执行</strong> intitialize() 来完成对引导启动器上下文环境设置</li></ul></li></ul></li><li><ul><li>让当前应用进入<strong>headless</strong>模式。<strong>java.awt.headless</strong></li><li><strong>获取所有</strong> <strong>RunListener****（运行监听器）【为了方便所有Listener进行事件感知】</strong></li></ul></li><li><ul><li><ul><li>getSpringFactoriesInstances 去<strong>spring.factories****找</strong> <strong>SpringApplicationRunListener</strong>. </li></ul></li></ul></li><li><ul><li>遍历 <strong>SpringApplicationRunListener 调用 starting 方法；</strong></li></ul></li><li><ul><li><ul><li><strong>相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。</strong></li></ul></li></ul></li><li><ul><li>保存命令行参数；ApplicationArguments</li><li>准备环境 prepareEnvironment（）;</li></ul></li><li><ul><li><ul><li>返回或者创建基础环境信息对象。<strong>StandardServletEnvironment</strong></li><li><strong>配置环境信息对象。</strong></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><strong>读取所有的配置源的配置属性值。</strong></li></ul></li></ul></li></ul></li><li><ul><li><ul><li>绑定环境信息</li><li>监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成</li></ul></li></ul></li><li><ul><li>创建IOC容器（createApplicationContext（））</li></ul></li><li><ul><li><ul><li>根据项目类型（Servlet）创建容器，</li><li>当前会创建 <strong>AnnotationConfigServletWebServerApplicationContext</strong></li></ul></li></ul></li><li><ul><li><strong>准备ApplicationContext IOC容器的基本信息</strong>  <strong>prepareContext()</strong></li></ul></li><li><ul><li><ul><li>保存环境信息</li><li>IOC容器的后置处理流程。</li><li>应用初始化器；applyInitializers；</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>遍历所有的 <strong>ApplicationContextInitializer 。调用</strong> <strong>initialize.。来对ioc容器进行初始化扩展功能</strong></li><li>遍历所有的 listener 调用 <strong>contextPrepared。EventPublishRunListenr；通知所有的监听器****contextPrepared</strong></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><strong>所有的监听器 调用</strong> <strong>contextLoaded。通知所有的监听器</strong> <strong>contextLoaded；</strong></li></ul></li></ul></li><li><ul><li><strong>刷新IOC容器。</strong>refreshContext</li></ul></li><li><ul><li><ul><li>创建容器中的所有组件（Spring注解）</li></ul></li></ul></li><li><ul><li>容器刷新完成后工作？afterRefresh</li><li>所有监听 器 调用 listeners.<strong>started</strong>(context); <strong>通知所有的监听器</strong> <strong>started</strong></li><li><strong>调用所有runners；</strong>callRunners()</li></ul></li><li><ul><li><ul><li><strong>获取容器中的</strong> <strong>ApplicationRunner</strong> </li><li><strong>获取容器中的</strong>  <strong>CommandLineRunner</strong></li><li><strong>合并所有runner并且按照@Order进行排序</strong></li><li><strong>遍历所有的runner。调用 run</strong> <strong>方法</strong></li></ul></li></ul></li><li><ul><li><strong>如果以上有异常，</strong></li></ul></li><li><ul><li><ul><li><strong>调用Listener 的 failed</strong></li></ul></li></ul></li><li><ul><li><strong>调用所有监听器的 running 方法</strong>  listeners.running(context); <strong>通知所有的监听器</strong> <strong>running</strong> </li><li><strong>running如果有问题。继续通知 failed 。****调用所有 Listener 的</strong> <strong>failed；****通知所有的监听器</strong> <strong>failed</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;h2 id=&quot;1-描述&quot;&gt;&lt;a href=&quot;#1-描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库知识点梳理</title>
    <link href="https://rockspeechcoder.github.io/2021/04/28/mysql-shu-ju-ku-zhi-shi-dian-shu-li/"/>
    <id>https://rockspeechcoder.github.io/2021/04/28/mysql-shu-ju-ku-zhi-shi-dian-shu-li/</id>
    <published>2021-04-28T03:27:30.000Z</published>
    <updated>2022-07-27T17:05:21.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库知识点梳理"><a href="#MySQL数据库知识点梳理" class="headerlink" title="MySQL数据库知识点梳理"></a>MySQL数据库知识点梳理</h1><h2 id="1-数据库基本命令"><a href="#1-数据库基本命令" class="headerlink" title="1. 数据库基本命令"></a>1. 数据库基本命令</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">MYSQL -UROOT -P123456 -- 连接数据库UPDATE MYSQL.USER SET AUTHENTICATION_STRING&#x3D;PASSWORD(&#39;123456&#39;) WHERE USER&#x3D;&#39;ROOT&#39; AND HOST&#x3D;&#39;LOCALHOST&#39;; -- 修改用户密码FLUSH PRIVILEGES; -- 刷新权限SHOW DATABASES; -- 查看所有数据库USE 数据库名; -- 切换数据库；SHOW TABLES; -- 查看数据库中所有表DESCRIBE 表名; -- 显示数据库中所有的表信息SHOW CREATE DATABASE &#96;库名&#96;; -- 查看创建数据库语句SHOW CREATE TABLE &#96;表名;&#96; -- 查看创建数据表语句DESC &#96;表名&#96;; -- 查看表结构EXIT; -- 退出连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE DATABASE [IF NOT EXISTS] 数据库名; -- 创建数据库DROP DATABASE [IF EXISTS] 数据库名; -- 删除数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-数据库的列类型"><a href="#3-数据库的列类型" class="headerlink" title="3. 数据库的列类型"></a>3. 数据库的列类型</h2><ul><li><p>数值</p><ul><li>tinyint 1字节</li><li>smallint 2字节</li><li>mediumint 3字节</li><li><strong>int 常用标准整数 4字节</strong></li><li>bigint 8字节</li><li>float 浮点数 4字节</li><li>double 浮点数 8字节</li><li>decimal 字符串形式的浮点数 用于金融计算</li></ul></li><li><p>字符串</p><ul><li>char 固定大小0~255</li><li><strong>varchar 可变字符串 0~65535</strong></li><li>tinytext 微型文本 2^8-1</li><li><strong>text 大文本 2^16-1</strong></li></ul></li><li><p>时间日期</p><ul><li>date YYYY-MM-DD 日期格式</li><li>time HH:mm:ss 时间格式</li><li><strong>datetime  YYYY-MM-DD HH:mm:ss 常用时间格式</strong></li><li>timestamp 时间戳</li><li>year 年份表示</li></ul></li><li><p>null</p></li></ul><h2 id="4-数据库字段属性"><a href="#4-数据库字段属性" class="headerlink" title="4. 数据库字段属性"></a>4. 数据库字段属性</h2><ul><li><p>Unsigned：</p><ul><li>无符号整数</li><li>声明该列不能为负数</li></ul></li><li><p>zerofill： 不足的位数0填充</p></li><li><p>自增： 设计唯一主键，类型必须为整数，可以自定义起始值和步长</p></li><li><p>非空：</p><ul><li>not null 不赋值会报错</li><li>null 不赋值默认为null</li></ul></li><li><p>default</p></li></ul><h2 id="5-数据表操作"><a href="#5-数据表操作" class="headerlink" title="5. 数据表操作"></a>5. 数据表操作</h2><ol><li><p>创建表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE [IF NOT EXISTS] &#96;表名&#96;( &#96;字段名&#96; 列类型 [属性] [索引] [注释],)[表类型][字符集][注释];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>修改表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 RENAME AS 表名; -- 修改表名 ALTER TABLE 表名 ADD 字段名 列属性; -- 表增加字段ALTER TABLE 表名 MODIFY 字段名 列属性; -- 表修改约束ALTER TABLE 表名 CHANGE 字段名 字段名 列属性; -- 表字段重命名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除表字段</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 DROP 字段名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除表</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP TABLE IF EXISTs 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="6-引擎"><a href="#6-引擎" class="headerlink" title="6. 引擎"></a>6. 引擎</h2><ul><li>INNODB（默认使用）：安全性高，事务处理。多表多用户操作<ul><li>支持事务</li><li>支持数据行锁定</li><li>支持外键约束</li><li>不支持全文索引</li><li>表空间大小：大</li></ul></li><li>MYISAM（较早版本使用）：节约空间，速度较快<ul><li>不支持事务</li><li>不支持数据行锁定</li><li>不支持外键约束</li><li>支持全文索引</li><li>表空间大小：小</li></ul></li></ul><h2 id="7-DML"><a href="#7-DML" class="headerlink" title="7. DML"></a>7. DML</h2><ul><li><p>插入</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表名([字段1,字段2]) values (&#39;值1&#39;,&#39;值2&#39;),(&#39;值1&#39;,&#39;值2&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">UPDATE 表名 SET 字段1 &#x3D; 值1, 字段2 &#x3D; 值2, WHERE [条件];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DELETE FROM 表名 WHERE [条件];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">TRUNCATE 表名; -- 清空表数据，重置自增列，不影响事务<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询    </p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT [ALL|DISTINCT|DISTINCTROW|TOP]&#123;*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]&#125;FROM TABLE [AS 别名][LEFT | RIGHT | INNER join TABLE on …][WHERE…][GROUP BY…] -- 通过哪个字段分组[HAVING…] -- 过滤分组的记录必须满足的次要条件[ORDER BY 字段名 ASC|DESC][LIMIT 查询起始下标,数量];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT @@auto_increment_increment; -- 查询自增步长<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="8-七种JOIN"><a href="#8-七种JOIN" class="headerlink" title="8. 七种JOIN"></a>8. 七种JOIN</h2><img src="/2021/04/28/mysql-shu-ju-ku-zhi-shi-dian-shu-li/qizhongjon.png" class=""><h2 id="9-MYSQL常用函数"><a href="#9-MYSQL常用函数" class="headerlink" title="9. MYSQL常用函数"></a>9. MYSQL常用函数</h2><ul><li>数学运算函数<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ABS(-8)  -- 8，绝对值CEILING(9.4) -- 10，向上取整FLOOR(9.4) -- 9，向下取整RAND() -- 返回0-1的随机数SIGN() -- 返回一个数的符号，正数1，负数-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>字符串函数<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CHAR_LENGTH(&#39;字符串长度&#39;) -- 返回字符串长度CONCAT(&#39;拼接&#39;,&#39;多个&#39;,&#39;字符串&#39;) -- 拼接字符串INSERT(源字符串,位置,长度,插入字符串) -- 查找位置替换对应长度的字符串LOWER(字符串) -- 转小写UPPER(字符串) -- 转大写INSTR(字符串,子串) -- 返回第一次出现的子串的位置REPLACE(字符串,被替换,需替换) -- 替换指定字符串SUBSTR(字符串,截取起始位置,长度) -- 截取指定位置和长度的字符串REVERSE(字符串) -- 反转MD5(明文) -- MD5 加密<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>时间和日期函数<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CURRENT_DATE() -- 获取当前日期CURDATE() -- 获取当前日期NOW() -- 获取当前时间，时分秒LOCALTIME -- 获取本地时间，时分秒SYSDATE() -- 系统时间YEAR()MONTH()DAY()HOUR()MINUTE()SECOND()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>系统函数<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SYSTEM_USER()USER()VERSION() -- 获取版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>聚合函数</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">COUNT() -- 统计数量，count(字段)忽略null，count(*),count(1)不会忽略nullSUM() -- 求和AVG() -- 求平均MAX() -- 求最大MIN() -- 求最小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-事务"><a href="#10-事务" class="headerlink" title="10. 事务"></a>10. 事务</h2><p>将一组SQL放在一个批次中去执行</p><ol><li><p>事务原则：ACID原则</p><ul><li><p>原子性：一起成功或一起失败</p></li><li><p>一致性：操作前后数据完整性最终一致</p></li><li><p>隔离性：多个用户同时操作，排除其他事务对本次事务的影响</p></li><li><p>持久性：事务结束后的数据不随外界原因导致丢失，事务未提交恢复原状，事务提交后持久化到数据库，一旦提交就不可逆</p></li></ul></li><li><p>事务的隔离级别</p><ul><li>脏读：一个事务读取到另一个事务未提交的数据</li><li>不可重复度：在一个事务内读取表中的某一行数据，多次读取结果不同</li><li>虚读（幻读）：在一个事务内读取到了别的事务插入的数据，导致前后读取不一致（比如多了一条）</li></ul></li><li><p>手动处理事务</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SET autocommit &#x3D; 0; 关闭事务自动提交START TRANSACTION; -- 标记一个事务开始...COMMIT; -- 提交ROLLBACK; -- 回滚SET autocommit &#x3D; 1; 开启事务自动提交SAVEPOINT; -- 保存点ROLLBACK TO SAVEPOINT; -- 回滚到保存点RELEASE  SAVEPOINT; -- 撤销保存点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="11-索引"><a href="#11-索引" class="headerlink" title="11. 索引"></a>11. 索引</h2><p>索引（index）是帮助MYSQL高效获取数据的数据结构。</p><ol><li><p>索引的分类</p><ul><li>主键索引（PRIMARY KEY）唯一标识，不可重复，只能有一个列作为主键</li><li>唯一索引（UNIQUE KEY）避免重复的列出现，多个列都可以标识</li><li>常规索引（KEY/INDEX）默认的</li><li>全文索引（FULLTEXT）快速定位数据，在特定数据库引擎下才有</li></ul></li><li><p>索引的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW INDEX FROM 表名; -- 显示所有索引信息ALTER TABLE 表名 ADD 索引类型 index 索引名(字段名); -- 添加索引CREATE INDEX 索引名 on 表名(字段名); -- 添加索引SELECT * FROM 表名 use index(索引名) WHERE ...; -- 提示SQL使用索引SELECT * FROM 表名 ignore index(索引名) WHERE ...; -- 提示SQL忽略使用索引SELECT * FROM 表名 force index(索引名) WHERE ...; -- 提示SQL必须使用索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>索引原则</p><ul><li>索引不是越多越好</li><li>不要对进程变动数据加索引</li><li>小数据量表不需要加索引</li><li>索引一般加在常用来查询的字段上</li><li>覆盖索引：查询使用了索引，并且需要返回的列在该索引中全部能找到，减少select *</li></ul></li><li><p>索引失效情况</p><ul><li>最左前缀原则：如果索引了多列（联合索引），查询从最左列开始，并且不跳过索引中的列。如果跳过某一列，索引将部分失效（后面的字段索引失效）。</li><li>联合索引中，出现范围查询（大于小于），范围查询右侧的列索引失效。业务允许的情况下使用大于等于、小于等于。</li><li>不要在索引列上进行运算，索引将失效。</li><li>字符串类型不加单引号，索引失效。</li><li>头部模糊匹配（%_），索引失效。尾部模糊匹配，索引不失效。</li><li>or分隔的条件，如果or两侧的条件有一侧无索引，则涉及的索引都不会被用到。</li><li>如果MySQL评估使用索引比全表扫描更慢，则不使用索引。</li></ul></li></ol><h2 id="12-用户管理"><a href="#12-用户管理" class="headerlink" title="12. 用户管理"></a>12. 用户管理</h2><p>用户表：mysql.user</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE USER 用户名 IDENTIFIED BY 密码; -- 创建用户SET PASSWORD &#x3D; PASSWORD(密码); -- 修改当前用户密码SET PASSWORD FOR 用户名 &#x3D; PASSWORD(密码); -- 修改指定用户密码RENAME USER 用户名 TO 新用户名; -- 重命名GRANT ALL PRIVILEGES ON 库.表 TO 用户; -- 用户授权所有权限SHOW GRANTS FOR 用户; -- 查询权限SHOW GRANTS FOR root@localhost; -- 查询权限REVOKE ALL PRIVILEGES ON 库.表 FROM 用户; -- 撤销权限DROP USER 用户名; -- 删除用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令行导出数据库：mysqldump -h主机名 -uroot -p密码 库名 表名1 表名2  &gt; 磁盘名/文件名</p><p>命令行导入数据库：source 磁盘名/文件名</p><h2 id="13-三大范式"><a href="#13-三大范式" class="headerlink" title="13. 三大范式"></a>13. 三大范式</h2><ul><li>第一范式（1NF）：数据库表的每一列都是不可分割的原子数据项</li><li>第二范式（2NF）：（满足第一范式）数据库表中的每一列都和主键相关，而不是只与主键的某一列相关</li><li>第三范式（3NF）：（满足第一范式和第二范式）数据库表的每一列都与主键直接相关，而不是间接相关</li></ul><h2 id="14-JDBC"><a href="#14-JDBC" class="headerlink" title="14. JDBC"></a>14. JDBC</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.jdbc.db;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import com.mysql.jdbc.Statement;public class DBUTIL &#123;privatestatic final String URL &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;database&quot;;private static final String USERNAME &#x3D; &quot;root&quot;;private static final String PASSWORD &#x3D; &quot;password&quot;;public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;&#x2F;&#x2F; JDBC 的三要素文件，加载驱动，获取连接，&#x2F;&#x2F;1. 加载驱动程序Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;2. 获取数据库的连接 Connection 数据库连接对象Connection connection &#x3D; DriverManager.getConnection(URL,USERNAME,PASSWORD);&#x2F;&#x2F;3. 通过数据库的连接操作数据库，实现增删改查，Statement SQL执行对象Statement statement &#x3D; connection.createStatement();&#x2F;&#x2F;4. 返回 ResultSet 对象，编写 sql 语句，实现最简单的增删改查ResultSet resultSet &#x3D; statement.executeQuery(&quot;select username,password from user&quot;);&#x2F;&#x2F;打印数据while(resultSet.next()) &#123;&#x2F;&#x2F;返回字符串System.out.println(rs.getString(&quot;username&quot;) + rs.getString(&quot;password&quot;));&#125;        &#x2F;&#x2F;5. 释放连接        resultSet.close();        statement.close();        connection.close();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.thb.study3;import com.thb.study2.Utils.JdbcUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class Test03 &#123;    public static void main(String[] args) &#123;        Connection connection &#x3D; null;        PreparedStatement preparedStatement &#x3D; null;&#x2F;&#x2F; 预执行        try &#123;            connection &#x3D; JdbcUtils.getConnection();            connection.setAutoCommit(false);&#x2F;&#x2F; 关闭自动提交，开启事务            String sql &#x3D; &quot;update account set money&#x3D;money-100 where &#96;name&#96;&#x3D;&#39;A&#39;&quot;;            preparedStatement &#x3D; connection.prepareStatement(sql);            preparedStatement.executeUpdate();            String sql2 &#x3D; &quot;update account set money&#x3D;money+100 where &#96;name&#96;&#x3D;&#39;B&#39;&quot;;            preparedStatement &#x3D; connection.prepareStatement(sql2);            preparedStatement.executeUpdate();            connection.commit();            System.out.println(&quot;成功&quot;);        &#125; catch (SQLException e) &#123;            &#x2F;&#x2F;默认失败会回滚            connection.rollback();            e.printStackTrace();        &#125;finally &#123;            JdbcUtils.release(connection,preparedStatement,null);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-视图"><a href="#15-视图" class="headerlink" title="15. 视图"></a>15. 视图</h2><p>虚拟存在的表，数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。只保留sql的查询逻辑，不保存查询结果。</p><p>作用：1. 简化用户对数据的理解，也简化用户的操作。2. 设定视图用户的操作权限。3. 屏蔽真实表结构变化带来的影响</p><ul><li><p>创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CERATE VIEW 视图名 AS SELECT语句  [WITH[CASCADED | LOCAL] CHECK OPTION]; -- CASCADED 检查依赖的视图，LOCAL不检查依赖的视图<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW CREATE VIEW 视图名;SELECT * FROM 视图名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CERATE OR REPLACE VIEW 视图名 AS SELECT语句  [WITH[CASCADED | LOCAL] CHECK OPTION]; -- 方式一ALTER VIEW 视图名 AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]; -- 方式二<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP VIEW [IF EXISTS] 视图名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="16-存储过程"><a href="#16-存储过程" class="headerlink" title="16. 存储过程"></a>16. 存储过程</h2><p>数据库sql语言层面的代码封装和重用。</p><ul><li><p>创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DELIMITER $$ -- 定义结束符CREATE PROCEDURE 存储过程名称([IN|OUT|INOUT 参数名 参数类型])BEGIN -- SQL语句END$$DELIMITER ; -- 重置结束符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>调用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CALL 名称([参数])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM INFORMATION_SCHEMA_ROUTINES WHERE ROUTINE_SCHEMA &#x3D; &#39;xxx&#39;;  -- 查询指定数据库的存储过程及状态信息SHOW CREATE PROCEDURE 存储过程名称;  -- 查询存储过程的定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP PROCEDURE [IF EXISTS] 存储过程名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>变量</p><ul><li><p>系统变量</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW [SESSION | GLOBAL] VARIABLES; -- 查看所有系统变量SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值SET [SESSION | GLOBAL] 系统变量名 &#x3D; 值; -- 设置系统变量SET @@[SESSION | GLOBAL] 系统变量名 &#x3D; 值; -- 设置系统变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>自定义变量</p><p>作用域：当前连接</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SET @var_name  &#x3D; expr[,@var_name  &#x3D; expr]...; -- 赋值SET @var_name  :&#x3D; expr[,@var_name  :&#x3D; expr]...; -- 赋值SELECT @var_name  &#x3D; expr[,@var_name  &#x3D; expr]...; -- 赋值SELECT 字段名 INTO @var_name FROM 表名; -- 赋值SELECT @var_name; -- 使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>局部变量</p><p>作用域：BEGIN … END块;</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DECLARE 变量名 变量类型[DEFAULT]; -- 声明SET 变量名 &#x3D; 值; -- 赋值SET 变量名 :&#x3D; 值; -- 赋值SELECT 字段名 INTO 变量名 FROM 表名; -- 赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 判断-- ifIF 条件1 THEN...ELSEIF 条件2 THENELSE...END IF;-- caseCASE case_valueWHEN ... THEN ...ELSEEND CASE;-- 循环-- whileWHILE 条件 DO... sqlEND WHILE;-- repeatREPEAT... sqlUNTIL 条件END REPEAT;-- loop[begin_label:]LOOP...sqlEND LOOP [end_label];-- 游标DECLARE 游标名称 CURSOR FOR 查询语句; -- 声明游标OPEN 游标名称; -- 打开游标FETCH 游标名称 INTO 变量[,变量]; -- 获取游标记录-- handlerDECLARE handler_action HANDLER FOR condition_value[,condition_value]... statement; -- handler_actionCONTINUE; -- 继续执行程序EXIT; -- 终止程序-- condition_valueSQLSTATE sqlstate_value; -- 状态码SQLWARNING; -- 所有以01开头的SQLSTATE代码的缩写NOT FOUND; -- 所有以02开头的SQLSTATE代码的缩写SQLEXCEPTION; -- 所有没被SQLWARNING和NOT FOUND捕获<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>存储函数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE FUNCTION 存储函数名称([参数列表])RETURNS TYPE [DETERMINISTIC | NO SQL |READS SQL DATA]BEGIN -- SQL语句RETURN ...;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="17-触发器"><a href="#17-触发器" class="headerlink" title="17. 触发器"></a>17. 触发器</h2><p>触发器是指与表有关的数据库对象，指在insert/update/delete之前或者之后，触发并执行触发器中定义的SQL集合。OLD，NEW指发生变化的记录内容</p><ul><li><p>创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TRIGGER trigger_nameBEFORE|AFTER INSERT|UPDATE|DELETEON tb_name FOR EACH ROW -- 行级触发器BEGINtrigger_stmt;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW TRIGGERS;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP TRIGGER [schema_name] trigger_name; -- 如果没有指定schema_name，默认当前数据库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="18-锁"><a href="#18-锁" class="headerlink" title="18. 锁"></a>18. 锁</h2><p>计算机协调多个进程或线程并发访问某一资源的机制。</p><ul><li><p>全局锁</p><p>对整个数据库实例加锁，加锁后处于只读状态。后续写操作将被阻塞。</p><p>使用场景：做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据完整性</p><pre class="line-numbers language-none"><code class="language-none">fush tables with read lock; -- 加全局锁unlock tables; -- 释放锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>表级锁</p><p>每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><ul><li><p>表锁</p><p>加锁：lock tables 表名… read/write</p><p>释放锁：unlock tables / 客户端连接关闭</p><ul><li><p>表共享读锁（read lock）：阻塞写，不阻塞其他客户端的读</p></li><li><p>表独占写锁（write lock）：阻塞其他客户端的读写，不阻塞自己的读写</p></li></ul></li><li><p>元数据锁（meta data lock）</p><p>系统自动控制，无需显式使用。访问表时会自动加上，维护表元数据的数据一致性。在表上有未提交的事务时，不可以对元数据进行写入操作。避免了DML和DDL的冲突，保证读写的正确性。</p><p>增删改查时，加MDL读锁（共享），表结构变更时，加MDL写锁（排他）。</p></li><li><p>意向锁</p><p>使用场景：加表锁时需要检查每一行的行锁，为解决效率低的问题，使用意向锁减少检查。</p><ul><li><p>意向共享锁（IS）</p><p>与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。</p></li><li><p>意向排他锁（IX）</p><p>与表锁共享锁（read）及表锁排他锁（write）都互斥，意向锁之间不互斥</p></li></ul></li></ul></li><li><p>行级锁</p><p>每次操作锁住对应表。锁定粒度小，发生锁冲突的概率最低，并发度最高。</p><p>通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</p><ul><li><p>行锁（record lock）</p><p>锁定单个记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p><ul><li><p>共享锁（S）：</p><p>允许一个事物去读一行，阻止其他事务获得相同数据集的排他锁。</p></li><li><p>排他锁（X）：</p><p>允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p></li></ul></li><li><p>间隙锁（gap lock）</p><p>锁定索引记录间隙（不含记录），确保索引记录间隙不变，防止其他事务insert产生幻读。在RR隔离级别下支持</p></li><li><p>临键锁（next-key-lock）</p><p>行锁和间隙锁的组合。在RR隔离级别下支持</p></li></ul></li></ul><h2 id="19-SQL性能分析"><a href="#19-SQL性能分析" class="headerlink" title="19. SQL性能分析"></a>19. SQL性能分析</h2><ul><li><p>SQL执行频率</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW GLOBAL STATUS LIKE &#39;Com_______)&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>开启慢查询日志</p></li></ul><p>​        /etc/my.cnf配置 ，配置完重启mysql</p><p>​        slow_query_log = 1 # 设置开启MYSQL慢查询日志</p><p>​        long_query_time = 2 # 设置SQL执行时间</p><ul><li><p>profile耗时详情</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show profiles;show profile [cpu] [for query query_id]; -- 耗时情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>expain</p><p>sql语句前加上explain/desc</p><ul><li><p>select _type</p><ul><li><p>SIMPLE 简单表，不使用表连接或者子查询</p></li><li><p>PRIMARY 主查询 外层的查询</p></li><li><p>UNION UNION中的第二个或者后面的查询语句</p></li><li><p>SUBQUERY SELECT / WHERE包含子查询</p></li></ul></li><li><p><strong>type</strong></p><p> ​    连接类型由好到差NULL（不访问表）、system（系统表）、const（主键或唯一索引）、eq_ref（唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配）、ref（非唯一性的索引）、range（使用索引返回一个范围中的行，如大于小于等情况）、index（用了索引但遍历索引树）、all（全表扫描）</p></li><li><p><strong>possible_key</strong> </p><p> 显示可能应用在这张表上的索引，一个或多个</p></li><li><p><strong>key</strong></p><p> 实际用到的索引，没有使用索引则为null</p></li><li><p><strong>key_len</strong></p><p> 索引中使用的字节数，索引字段最大可能长度（并非实际使用长度），长度越短越好</p></li><li><p>rows</p><p> mysql认为必须要执行查询的行数（不准确的估计值）</p></li><li><p>filtered</p><p> 表示返回结果行数占需读取行数的百分比，值越大越好</p></li><li><p>extra</p><ul><li>using index condition; 查找使用了索引，但是需要回表查询数据</li><li>using where;using index; 查找使用了索引，但是需要的数据都在索引列中能找到，不需要回表查询数据</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL数据库知识点梳理&quot;&gt;&lt;a href=&quot;#MySQL数据库知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库知识点梳理&quot;&gt;&lt;/a&gt;MySQL数据库知识点梳理&lt;/h1&gt;&lt;h2 id=&quot;1-数据库基本命令&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="数据库" scheme="https://rockspeechcoder.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架 - SpringMVC</title>
    <link href="https://rockspeechcoder.github.io/2021/02/11/ssm-kuang-jia-springmvc/"/>
    <id>https://rockspeechcoder.github.io/2021/02/11/ssm-kuang-jia-springmvc/</id>
    <published>2021-02-11T12:27:18.000Z</published>
    <updated>2022-08-25T11:54:46.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>​    MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分，SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、 WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目 表述层开发的首选方案。</p><ul><li><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类：</p><ul><li><p> 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 </p></li><li><p>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 </p></li></ul></li><li><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p></li><li><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller 调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。</p></li></ul><h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h2><pre><code>- Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 - 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一 处理 - 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 - 代码清新简洁，大幅度提升开发效率 - 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 - 性能卓著，尤其适合现代大型、超大型互联网项目要求</code></pre><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- SpringMVC --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 日志 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>ch.qos.logback<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>logback-classic<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- ServletAPI --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javax.servlet-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- Spring5和Thymeleaf整合包 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>thymeleaf-spring5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.0.12.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- contextConfigLocation为固定值 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的        src/main/resources --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:springMVC.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--    作为框架的核心组件，在启动过程中有大量的初始化操作要做    而这些操作放在第一次请求时才执行会严重影响访问速度    因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--    设置springMVC的核心控制器所能处理的请求的请求路径    /所匹配的请求可以是/login或.html或.js或.css方式的请求路径    但是/不能匹配.jsp请求路径的请求    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 自动扫描包 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.mvc.controller<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 配置Thymeleaf视图解析器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewResolver<span class="token punctuation">"</span></span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.thymeleaf.spring5.view.ThymeleafViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>order<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>characterEncoding<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>templateEngine<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.thymeleaf.spring5.SpringTemplateEngine<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>templateResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span>                <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token comment">&lt;!-- 视图前缀 --></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/WEB-INF/templates/<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                    <span class="token comment">&lt;!-- 视图后缀 --></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.html<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>templateMode<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTML5<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>characterEncoding<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--处理静态资源，例如html、js、css、jpg若只设置该标签，则只能访问静态资源，其他请求则无法访问此时必须设置&lt;mvc:annotation-driven/>解决问题--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>default-servlet-handler</span><span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 开启mvc注解驱动 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>message-converters</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 处理响应中文内容乱码 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span>        <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.http.converter.StringHttpMessageConverter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>defaultCharset<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>supportedMediaTypes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>text/html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>application/json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>message-converters</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-RequestMapping"><a href="#4-RequestMapping" class="headerlink" title="4. @RequestMapping"></a>4. @RequestMapping</h2><ol><li><p>作用：</p><p>就是将请求和处理请求的控制器方法关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p></li><li><p>位置：</p><ul><li><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息 </p></li><li><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p></li></ul></li><li><p>value属性：</p><ul><li><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射 </p></li><li><p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p></li><li><p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p></li></ul></li><li><p>method属性：</p><ul><li><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 </p></li><li><p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p></li></ul></li><li><p>params属性：</p><ul><li>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射 </li><li>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 <ul><li>“param”：要求请求映射所匹配的请求必须携带param请求参数</li><li>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数 </li><li>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value </li><li>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</li></ul></li></ul></li><li><p>headers属性：</p><ul><li>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射 </li><li>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系<ul><li>“header”：要求请求映射所匹配的请求必须携带header请求头信息 </li><li>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息 </li><li>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value </li><li>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</li></ul></li></ul></li><li><p>SpringMVC支持ant风格的路径：</p><ul><li><p>？：表示任意的单个字符 </p></li><li><p>*：表示任意的0个或多个字符 </p></li><li><p>**：表示任意层数的任意目录</p></li></ul></li><li><p>支持路径中的占位符</p><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参。</p></li></ol><h2 id="5-SpringMVC获取请求参数"><a href="#5-SpringMVC获取请求参数" class="headerlink" title="5. SpringMVC获取请求参数"></a>5. SpringMVC获取请求参数</h2><ol><li><p>通过ServletAPI获取</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;testParam&quot;)public String testParam(HttpServletRequest request)&#123;    String username &#x3D; request.getParameter(&quot;username&quot;);    String password &#x3D; request.getParameter(&quot;password&quot;);    System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password);    return &quot;success&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过控制器方法的形参获取</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;testParam&quot;)public String testParam(String username, String password)&#123;    System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password);    return &quot;success&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>@RequestParam</p><ul><li>@RequestParam是将请求参数和控制器方法的形参创建映射关系 </li><li>@RequestParam注解一共有三个属性： <ul><li>value：指定为形参赋值的请求参数的参数名 </li><li>required：设置是否必须传输此请求参数，默认值为true <ul><li>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；</li><li>若设置为 false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为 null </li></ul></li><li>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</li></ul></li></ul></li><li><p>@RequestHeader</p><ul><li><p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系 </p></li><li><p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p></li></ul></li><li><p>@CookieValue</p><ul><li>@CookieValue是将cookie数据和控制器方法的形参创建映射关系 </li><li>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</li></ul></li><li><p>通过POJO获取</p><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实 体类中的属性名一致，那么请求参数就会为此属性赋值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;testpojo&quot;)public String testPOJO(User user)&#123;    System.out.println(user);    return &quot;success&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="6-RequestBody"><a href="#6-RequestBody" class="headerlink" title="6. @RequestBody"></a>6. @RequestBody</h2><ol><li><p>@RequestBody</p><p>可以获取请求体信息，使用@RequestBody注解标识控制器方法的形参，当前请求的请求体就会为当前注解所标识的形参赋值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;test&#x2F;RequestBody&quot;)public String testRequestBody(@RequestBody String requestBody)&#123;    System.out.println(&quot;requestBody:&quot;+requestBody);    return &quot;success&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>@RequestBody获取json格式的请求参数</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 导入jackson的依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.12.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;将json格式的数据转换为map集合@RequestMapping(&quot;&#x2F;test&#x2F;RequestBody&#x2F;json&quot;)public void testRequestBody(@RequestBody Map&lt;String, Object&gt; map,HttpServletResponse response) throws IOException &#123;    System.out.println(map);    &#x2F;&#x2F;&#123;username&#x3D;admin, password&#x3D;123456&#125;    response.getWriter().print(&quot;hello,axios&quot;);&#125;&#x2F;&#x2F;将json格式的数据转换为实体类对象@RequestMapping(&quot;&#x2F;test&#x2F;RequestBody&#x2F;json&quot;)public void testRequestBody(@RequestBody User user, HttpServletResponseresponse) throws IOException &#123;    System.out.println(user);    &#x2F;&#x2F;User&#123;id&#x3D;null, username&#x3D;&#39;admin&#39;, password&#x3D;&#39;123456&#39;, age&#x3D;null,    gender&#x3D;&#39;null&#39;&#125;    response.getWriter().print(&quot;hello,axios&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="7-ResponseBody"><a href="#7-ResponseBody" class="headerlink" title="7. @ResponseBody"></a>7. @ResponseBody</h2><ol><li><p>@ResponseBody</p><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p></li><li><p>@ResponseBody响应浏览器json数据</p><p>服务器处理ajax请求之后，大多数情况都需要向浏览器响应一个java对象，此时必须将java对象转换为 json字符串才可以响应到浏览器，之前我们使用操作json数据的jar包gson或jackson将java对象转换为 json字符串。在SpringMVC中，我们可以直接使用@ResponseBody注解实现此功能</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 导入jackson的依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.12.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;响应浏览器list集合@RequestMapping(&quot;&#x2F;test&#x2F;ResponseBody&#x2F;json&quot;)@ResponseBodypublic List&lt;User&gt; testResponseBody()&#123;    User user1 &#x3D; new User(1001,&quot;admin1&quot;,&quot;123456&quot;,23,&quot;男&quot;);    User user2 &#x3D; new User(1002,&quot;admin2&quot;,&quot;123456&quot;,23,&quot;男&quot;);    User user3 &#x3D; new User(1003,&quot;admin3&quot;,&quot;123456&quot;,23,&quot;男&quot;);    List&lt;User&gt; list &#x3D; Arrays.asList(user1, user2, user3);    return list;&#125;&#x2F;&#x2F;响应浏览器map集合@RequestMapping(&quot;&#x2F;test&#x2F;ResponseBody&#x2F;json&quot;)@ResponseBodypublic Map&lt;String, Object&gt; testResponseBody()&#123;    User user1 &#x3D; new User(1001,&quot;admin1&quot;,&quot;123456&quot;,23,&quot;男&quot;);    User user2 &#x3D; new User(1002,&quot;admin2&quot;,&quot;123456&quot;,23,&quot;男&quot;);    User user3 &#x3D; new User(1003,&quot;admin3&quot;,&quot;123456&quot;,23,&quot;男&quot;);    Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();    map.put(&quot;1001&quot;, user1);    map.put(&quot;1002&quot;, user2);    map.put(&quot;1003&quot;, user3);    return map;&#125;&#x2F;&#x2F;响应浏览器实体类对象@RequestMapping(&quot;&#x2F;test&#x2F;ResponseBody&#x2F;json&quot;)@ResponseBodypublic User testResponseBody()&#123;return user;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="8-RestController注解"><a href="#8-RestController注解" class="headerlink" title="8. @RestController注解"></a>8. @RestController注解</h2><p>​    @RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了 @Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><h2 id="9-拦截器"><a href="#9-拦截器" class="headerlink" title="9. 拦截器"></a>9. 拦截器</h2><ol><li><p>拦截器配置</p><ul><li><p>SpringMVC中的拦截器用于拦截控制器方法的执行 </p></li><li><p>SpringMVC中的拦截器需要实现HandlerInterceptor </p></li><li><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.interceptor.MyInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/**<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/testRequestEntity<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>三个抽象方法</p><ul><li>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 </li><li>postHandle：控制器方法执行之后执行postHandle() </li><li>afterCompletion：处理完视图和模型数据，渲染视图完毕之后执行afterCompletion()</li></ul></li><li><p>执行顺序</p><ol><li>若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterCompletion()会按照配置的反序执行 </li><li>若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false 的拦截器之前的拦截器的afterCompletion()会执行</li></ol></li></ol><h2 id="10-注解配置MVC"><a href="#10-注解配置MVC" class="headerlink" title="10. 注解配置MVC"></a>10. 注解配置MVC</h2><ol><li><p>创建初始化类，代替web.xml</p><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类， 如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为 SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配 置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为 AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了 AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自 动发现它，并用它来配置Servlet上下文。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123;        &#x2F;**    * 指定spring的配置类    * @return    *&#x2F;    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;    return new Class[]&#123;SpringConfig.class&#125;;    &#125;        &#x2F;**    * 指定SpringMVC的配置类    * @return    *&#x2F;        @Override    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;    return new Class[]&#123;WebConfig.class&#125;;    &#125;    &#x2F;**    * 指定DispatcherServlet的映射规则，即url-pattern    * @return    *&#x2F;        @Override    protected String[] getServletMappings() &#123;    return new String[]&#123;&quot;&#x2F;&quot;&#125;;    &#125;        &#x2F;**    * 添加过滤器    * @return    *&#x2F;    @Override    protected Filter[] getServletFilters() &#123;        CharacterEncodingFilter encodingFilter &#x3D; new CharacterEncodingFilter();        encodingFilter.setEncoding(&quot;UTF-8&quot;);        encodingFilter.setForceRequestEncoding(true);        HiddenHttpMethodFilter hiddenHttpMethodFilter &#x3D; new        HiddenHttpMethodFilter();        return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建SpringConfig配置类，代替spring的配置文件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SpringConfig &#123;&#x2F;&#x2F;ssm整合之后，spring的配置信息写在此类中&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建WebConfig配置类，代替SpringMVC的配置文件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration&#x2F;&#x2F;扫描组件@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)&#x2F;&#x2F;开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;        &#x2F;&#x2F;使用默认的servlet处理静态资源    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer    configurer) &#123;    configurer.enable();    &#125;        &#x2F;&#x2F;配置文件上传解析器    @Bean    public CommonsMultipartResolver multipartResolver()&#123;    return new CommonsMultipartResolver();    &#125;        &#x2F;&#x2F;配置拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;    MyInterceptor MyInterceptor &#x3D; new MyInterceptor();    registry.addInterceptor(MyInterceptor).addPathPatterns(&quot;&#x2F;**&quot;);    &#125;        &#x2F;&#x2F;配置生成模板解析器    @Bean    public ITemplateResolver templateResolver() &#123;        WebApplicationContext webApplicationContext &#x3D;        ContextLoader.getCurrentWebApplicationContext();        &#x2F;&#x2F; ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过        WebApplicationContext 的方法获得        ServletContextTemplateResolver templateResolver &#x3D; new        ServletContextTemplateResolver(        webApplicationContext.getServletContext());        templateResolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;templates&#x2F;&quot;);        templateResolver.setSuffix(&quot;.html&quot;);        templateResolver.setCharacterEncoding(&quot;UTF-8&quot;);        templateResolver.setTemplateMode(TemplateMode.HTML);        return templateResolver;    &#125;        &#x2F;&#x2F;生成模板引擎并为模板引擎注入模板解析器    @Bean    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123;        SpringTemplateEngine templateEngine &#x3D; new SpringTemplateEngine();        templateEngine.setTemplateResolver(templateResolver);        return templateEngine;    &#125;        &#x2F;&#x2F;生成视图解析器并为解析器注入模板引擎    @Bean    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123;    ThymeleafViewResolver viewResolver &#x3D; new ThymeleafViewResolver();    viewResolver.setCharacterEncoding(&quot;UTF-8&quot;);    viewResolver.setTemplateEngine(templateEngine);    return viewResolver;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="11-SpringMVC执行流程"><a href="#11-SpringMVC执行流程" class="headerlink" title="11. SpringMVC执行流程"></a>11. SpringMVC执行流程</h2><ol><li><p>SpringMVC常用组件</p><ul><li><p>DispatcherServlet：前端控制器，不需要工程师开发，由框架提供。</p><p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 </p></li><li><p>HandlerMapping：处理器映射器，不需要工程师开发，由框架提供。</p><p>作用：根据请求的url、method等信息查找Handler，即控制器方法 </p></li><li><p>Handler：处理器，需要工程师开发。</p><p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p></li><li><p>HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供。</p><p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行 </p></li><li><p>ViewResolver：视图解析器，不需要工程师开发，由框架提供。</p><p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、 RedirectView </p></li><li><p>View：视图 </p><p>作用：将模型数据通过页面展示给用户</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringMVC&quot;&gt;&lt;a href=&quot;#SpringMVC&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC&quot;&gt;&lt;/a&gt;SpringMVC&lt;/h1&gt;&lt;h2 id=&quot;1-描述&quot;&gt;&lt;a href=&quot;#1-描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架 - Spring</title>
    <link href="https://rockspeechcoder.github.io/2020/10/02/ssm-kuang-jia-spring/"/>
    <id>https://rockspeechcoder.github.io/2020/10/02/ssm-kuang-jia-spring/</id>
    <published>2020-10-02T08:56:33.000Z</published>
    <updated>2022-08-25T11:54:10.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>   轻量级框架。创建性能良好、易于测试、可重用的代码</p><h2 id="2-Spring-Framework"><a href="#2-Spring-Framework" class="headerlink" title="2. Spring Framework"></a>2. Spring Framework</h2><ol><li><p>特性：</p><ul><li><p>非侵入性</p><p>对应用程序本身的结构侵入性较小</p></li><li><p>控制反转IOC（Invension Of Control）</p><p>翻转资源获取方向。把自己创建资源、向环境索取资源转变为环境将资源准备好，我们享受资源注入</p></li><li><p>面向切面编程AOP （Aspect Oriented Programming）</p><p>在不修改源代码的基础下增强代码功能</p></li><li><p>容器</p><p>Spring IOC是一个容器，包含并且管理组件对象的生命周期。组件享受容器的管理，屏蔽了组件创建过程中的大量细节，降低了使用门槛，提高开发效率</p></li><li><p>组件化</p><p>使用简单的组件配置组合成一个最复杂的应用。在Spring中可以使用XML和Java注解组合这些对象</p></li><li><p>声明式</p><p>声明需求即可由框架实现</p></li><li><p>一站式</p><p>在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库</p></li></ul></li><li><p>功能模块</p><ul><li><p>Core Container</p><p>核心容器。在Spring环境下使用任何功能必须基于IOC容器</p></li><li><p>AOP Aspects</p><p>面向切面编程</p></li><li><p>Testing</p><p>提供了对junit或TestNG测试框架的整合</p></li><li><p>Data Access/Integration</p><p>提供了对数据访问/集成的功能</p></li><li><p>Spring MVC</p><p>提供了面向Web应用程序的集成功能</p></li></ul></li></ol><h2 id="3-IOC"><a href="#3-IOC" class="headerlink" title="3. IOC"></a>3. IOC</h2><ol><li><p>思想：</p><p>反转了资源的获取方向——改由容器主 动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式。</p></li><li><p>DI （Dependency Injection）：依赖注入</p><p>组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器 的资源注入。DI 是对 IOC 的一种具体实现。</p></li></ol><h2 id="4-两种实现方式"><a href="#4-两种实现方式" class="headerlink" title="4. 两种实现方式"></a>4. 两种实现方式</h2><ul><li><p>BeanFactory： 这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</p></li><li><p>ApplicationContext： BeanFactory的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</p><ul><li><p>ApplicationContext的主要实现类：</p><ul><li><p>ClassPathXmlApplicationContext </p><p>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器 对象</p></li><li><p>FileSystemXmlApplicationContext</p><p>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容 器对象</p></li><li><p>ConfigurableApplicationContext</p><p>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、 关闭和刷新上下文的能力</p></li><li><p>WebApplicationContext</p><p>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对 象，并将对象引入存入 ServletContext 域中</p></li></ul></li></ul></li></ul><h2 id="5-管理Bean"><a href="#5-管理Bean" class="headerlink" title="5. 管理Bean"></a>5. 管理Bean</h2><ol><li><p>Bean作用域（scope属性）</p><ul><li>singleton（默认） 单例，IOC容器初始化时创建对象</li><li>prototype 多例，获取bean时创建对象</li></ul><p>WebApplicationContext环境下额外的作用域（不常用）：</p><ul><li>request 在一个请求范围内有效</li><li>session 在一个会话范围内有效</li></ul></li><li><p>生命周期</p><ol><li><p>bean对象创建，实例化（调用无参构造器）</p></li><li><p>给bean对象设置属性，依赖注入</p></li><li><p>bean对象初始化之前操作（由bean的后置处理器负责，实现BeanPostProcessor接口， 且配置到IOC容器中）</p><p>bean后置处理器不是单独针对某一个bean生效，而是针对IOC容 器中所有bean都会执行</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBeanProcessor<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring.process.MyBeanProcessor<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyBeanProcessor implements BeanPostProcessor &#123;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName)    throws BeansException &#123;        System.out.println(&quot;☆☆☆&quot; + beanName + &quot; &#x3D; &quot; + bean);        return bean;    &#125;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName)    throws BeansException &#123;        System.out.println(&quot;★★★&quot; + beanName + &quot; &#x3D; &quot; + bean);        return bean;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>bean对象初始化（需在配置bean时指定初始化方法 init-method=”initMethod”）</p></li><li><p>bean对象初始化之后操作（由bean的后置处理器负责，实现BeanPostProcessor接口， 且配置到IOC容器中）</p></li><li><p>bean对象就绪可以使用</p></li><li><p>bean对象销毁（需在配置bean时指定销毁方法 destroy-method=”destroyMethod”）</p></li><li><p>IOC容器关闭</p></li></ol></li><li><p>基于xml</p><ul><li><p>依赖</p><img src="/2020/10/02/ssm-kuang-jia-spring/image-1.png" class=""></li><li><p>resources/applicationContext.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--        配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理        通过bean标签配置IOC容器所管理的bean        属性：        id：设置bean的唯一标识        class：设置bean所对应类型的全类名，默认无参构造    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>helloworld<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.ssm.pojo.HelloWorld<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取ioc及bean对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取ioc容器ApplicationContext ioc &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);&#x2F;&#x2F; 获取ioc容器的bean（方式1）HelloWorld bean &#x3D; (HelloWorld) ioc.getBean(&quot;helloworld&quot;);&#x2F;&#x2F; 【常用】获取ioc容器的bean（方式2）要求IOC容器中指定类型的bean有且只能有一个HelloWorld bean &#x3D; ac.getBean(HelloWorld.class);&#x2F;&#x2F; 获取ioc容器的bean（方式3）HelloWorld bean &#x3D; ac.getBean(&quot;helloworld&quot;, HelloWorld.class);bean.learnSpring();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建对象（利用反射及工厂模式）</p><p>一个bean对应一个对象（单例），接口不能</p><img src="/2020/10/02/ssm-kuang-jia-spring/image-2.png" class=""><img src="/2020/10/02/ssm-kuang-jia-spring/image-3.png" class=""></li><li><p>依赖注入</p><ul><li><p>setter注入</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.spring.pojo.People<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--通过成员变量的set方法赋值--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Tom<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>null</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--类类型方法一：引用外部bean--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazz<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazzOne<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--类类型方法二：级联--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazz.name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazzTwo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--类类型方法三：内部bean--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazz<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazzThree<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.spring.pojo.Clazz<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!--通过成员变量的set方法赋值--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazzOne<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>array<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazzOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.spring.pojo.Clazz<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--通过成员变量的set方法赋值--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clazzOne<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--List类型方法一--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>People<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!--&lt;value>&lt;/value> --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleOne<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleTwo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--List类型方法二--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>People<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--Map类型方法一--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>People<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>key1<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleOne<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>key2<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleTwo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--List类型方法二--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>People<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--Map类型方法二--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>People<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--配置集合类型的bean，需要util约束--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">util:</span>list</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleOne<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleTwo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">util:</span>list</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--配置集合类型的bean，需要util约束--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">util:</span>list</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>key1<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleOne<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>key2<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleTwo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">util:</span>list</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--命名空间赋值--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.spring.pojo.People<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">p:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">p:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Sam<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">p:</span>mapBean-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构造器注入</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleTwo<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.spring.pojo.People<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--通过有参构造器赋值，只有一个构造器按顺序填参数--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token entity named-entity" title="&lt;">&amp;lt;</span>Jerry<span class="token entity named-entity" title="&gt;">&amp;gt;</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>管理数据源</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- MySQL驱动 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0.16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 数据源 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0.31<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 引入外部属性文件 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath:jdbc.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>druidDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.url&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.driver&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.user&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.password&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>FactoryBean</p><p>配置一个 FactoryBean类型的实现类bean，在获取bean的时候得到的并不是class属性中配置的实现类的对象，而是 getObject()方法的返回值（交给ioc管理）。通过这种机制，Spring可以把复杂组件创建的详细过程和繁琐细节都屏蔽起来</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserFactoryBean implements FactoryBean&lt;User&gt; &#123;    @Override    public User getObject() throws Exception &#123;        return new User();    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;    return User.class;    &#125;&#125;@Testpublic void testUserFactoryBean()&#123;&#x2F;&#x2F;获取IOC容器ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;spring-factorybean.xml&quot;);    User user &#x3D; (User) ac.getBean(&quot;user&quot;);    System.out.println(user);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.bean.UserFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>基于xml的自动装配</p><p>autowire，根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的<strong>类类型或接口类型</strong>属性赋值</p><ul><li>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值 若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值 null 若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException</li><li>byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</li></ul></li></ul></li><li><p>基于注解</p><p>类名首字母小写就是bean的id。例如：UserController类对应的bean的id就是userController。 自定义bean的id 可通过标识组件的注解的value属性设置自定义的bean的id</p><ul><li><p>@Component：将类标识为普通组件 </p></li><li><p>@Controller：将类标识为控制层组件 </p></li><li><p>@Service：将类标识为业务层组件 </p></li><li><p>@Repository：将类标识为持久层组件</p></li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>包名<span class="token punctuation">"</span></span> <span class="token attr-name">use-default-filters</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- context:exclude-filter标签：指定排除规则 --></span><span class="token comment">&lt;!--type：设置排除或包含的依据type="annotation"，根据注解排除，expression中设置要排除的注解的全类名type="assignable"，根据类型排除，expression中设置要排除的类型的全类名--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>exclude-filter</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>annotation<span class="token punctuation">"</span></span><span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.stereotype.Controller<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--&lt;context:exclude-filter type="assignable"expression="全类名"/>--></span>    <span class="token comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --></span><span class="token comment">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --></span><span class="token comment">&lt;!-- 此时必须设置use-default-filters="false"，因为默认规则即扫描指定包下所有类 --></span><span class="token comment">&lt;!--    type：设置排除或包含的依据    type="annotation"，根据注解指定，expression中设置要指定的注解的全类名    type="assignable"，根据类型指定，expression中设置要指定的类型的全类名--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>include-filter</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>annotation<span class="token punctuation">"</span></span><span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.stereotype.Controller<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!--&lt;context:include-filter type="assignable"    expression="全类名"/>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><p>自动装配</p><ul><li><p>@Autowired，不需要提供setXxx()方法，可以标记在成员变量、构造器和set方法上</p></li><li><p>工作流程</p><p>首先根据所需要的组件类型到IOC容器中查找 </p><ul><li>能够找到唯一的bean：直接执行装配 </li><li>如果完全找不到匹配这个类型的bean：装配失败 </li><li>和所需类型匹配的bean不止一个 </li><li>没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配 <ul><li>能够找到：执行装配 </li><li>找不到：装配失败 </li></ul></li><li>使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配 <ul><li>能够找到：执行装配 </li><li>找不到：装配失败</li></ul></li></ul></li></ul></li></ul><h2 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6. AOP"></a>6. AOP</h2><ol><li><p>描述：</p><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面 向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在不修改源代码的情况 下给程序动态统一添加额外功能的一种技术。本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p></li><li><p>相关概念</p><ul><li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；封装通知方法的类。</li><li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；向目标对象应用通知之后创建的代理对象。</li><li>Pointcut：切入点，即一组连接点的集合；每个类的方法中都包含多个连接点，</li><li>Advice：增强，指特定连接点上执行的动作；</li><li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li><li>Weaving：织入，指将切面整合到程序的执行流程中；</li><li>Interceptor：拦截器，是一种实现增强的方式；</li><li>Target Object：目标对象，即真正执行业务的核心逻辑对象；被代理的目标对象。</li><li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用；向目标对象应用通知之后创建的代理对象。</li></ul></li><li><p>作用：</p><ul><li>简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能， 提高内聚性。 </li><li>代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就 被切面给增强了。</li></ul></li><li><p>基于注解的AOP</p><ol><li><p>说明</p><ul><li><p>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因 为这个技术要求代理对象和目标对象实现同样的接口。 </p></li><li><p>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口。 </p></li><li><p>AspectJ：本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</p><ul><li>@Aspect 将当前组件表示为切面</li><li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li><li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li><li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li><li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li><li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li></ul></li></ul></li><li><p>依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-aspects<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--    基于注解的AOP的实现：    1、将目标对象和切面交给IOC容器管理（注解+扫描）    2、开启AspectJ的自动代理，为目标对象自动生成代理    3、将切面类通过注解@Aspect标识--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>包名<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>切入点执行语法</p><img src="/2020/10/02/ssm-kuang-jia-spring/image-4.png" class=""></li><li><p>获取信息</p><ul><li><p>获取连接点信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Before(&quot;execution(public int com.aop.annotation.TestImpl.*(..))&quot;) public void beforeMethod(JoinPoint joinPoint)&#123;     &#x2F;&#x2F;获取连接点的声明信息     String methodName &#x3D; joinPoint.getSignature().getName();     &#x2F;&#x2F;获取目标方法到的实参信息     String args &#x3D; Arrays.toString(joinPoint.getArgs());     System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取目标方法返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@AfterReturning(value &#x3D; &quot;execution(* com.aop.annotation.TestImpl.*(..))&quot;, returning &#x3D; &quot;result&quot;)public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;    String methodName &#x3D; joinPoint.getSignature().getName();    System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取目标方法的异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@AfterThrowing(value &#x3D; &quot;execution(* com.aop.annotation.TestImpl.*(..))&quot;, throwing &#x3D; &quot;ex&quot;)public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123;    String methodName &#x3D; joinPoint.getSignature().getName();    System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>@Around</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Around(&quot;execution(* com.aop.annotation.TestImpl.*(..))&quot;)public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;    String methodName &#x3D; joinPoint.getSignature().getName();    String args &#x3D; Arrays.toString(joinPoint.getArgs());    Object result &#x3D; null;    try &#123;    System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);    &#x2F;&#x2F;目标方法的执行，目标方法的返回值一定要返回给外界调用者    result &#x3D; joinPoint.proceed();    System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);    &#125; catch (Throwable throwable) &#123;    throwable.printStackTrace();    System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);    &#125; finally &#123;    System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>切面的优先级<br>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 </p><ul><li><p>外部切面的优先级比内部切面的优先级高</p></li><li><p>使用@Order注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低</p></li></ul></li></ol></li></ol><h2 id="7-声明式事务"><a href="#7-声明式事务" class="headerlink" title="7. 声明式事务"></a>7. 声明式事务</h2><ol><li><p>JdbcTemplate</p><ol><li><p>依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- Spring 持久化层支持jar包 --></span>    <span class="token comment">&lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个    jar包 --></span>    <span class="token comment">&lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-orm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- Spring 测试相关 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- junit测试 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- MySQL驱动 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0.16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 数据源 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0.31<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--扫描组件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring.tx.annotation<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 导入外部属性文件 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath:jdbc.properties<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 配置数据源 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>druidDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.url&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.driver&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.username&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.password&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 配置 JdbcTemplate --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbcTemplate<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.jdbc.core.JdbcTemplate<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 装配数据源 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>druidDataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring-jdbc.xml&quot;)public class JDBCTemplateTest &#123;    @Autowired    private JdbcTemplate jdbcTemplate;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>基于注解</p><ol><li>添加事务配置</li></ol> <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 配置事务管理器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--开启事务的注解驱动通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务--></span><span class="token comment">&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>回滚策略<ul><li>rollbackFor属性：需要设置一个Class类型的对象 </li><li>rollbackForClassName属性：需要设置一个字符串类型的全类名 </li><li>noRollbackFor属性：需要设置一个Class类型的对象 </li><li>rollbackFor属性：需要设置一个字符串类型的全类名</li></ul></li><li>事务隔离级别<ul><li>读未提交：READ UNCOMMITTED 允许Transaction01读取Transaction02未提交的修改。 </li><li>读已提交：READ COMMITTED、 要求Transaction01只能读取Transaction02已提交的修改。 </li><li>可重复读：REPEATABLE READ 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。 </li><li>串行化：SERIALIZABLE 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它 事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</li></ul></li><li>事务传播行为<ul><li>@Transactional(propagation = Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开 启的事务可用，那么就在这个事务中运行。</li><li>@Transactional(propagation = Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启 的事务，都要开启新事务。</li></ul></li></ol></li><li><p>基于xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 配置事务通知和切入点表达式 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>advisor</span> <span class="token attr-name">advice-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>execution(*    com.learn.spring.tx.xml.service.impl.*.*(..))<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>advisor</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- tx:advice标签：配置事务通知 --></span><span class="token comment">&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --></span><span class="token comment">&lt;!-- transaction-manager属性：关联事务管理器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- tx:method标签：配置具体的事务方法 --></span>        <span class="token comment">&lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>get*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>query*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>find*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment">&lt;!-- read-only属性：设置只读属性 --></span>        <span class="token comment">&lt;!-- rollback-for属性：设置回滚的异常 --></span>        <span class="token comment">&lt;!-- no-rollback-for属性：设置不回滚的异常 --></span>        <span class="token comment">&lt;!-- isolation属性：设置事务的隔离级别 --></span>        <span class="token comment">&lt;!-- timeout属性：设置事务的超时属性 --></span>        <span class="token comment">&lt;!-- propagation属性：设置事务的传播行为 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>save*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">rollbackfor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Exception<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRES_NEW<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>update*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">rollbackfor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Exception<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRES_NEW<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>delete*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">rollbackfor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Exception<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRES_NEW<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-aspects<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;1-描述&quot;&gt;&lt;a href=&quot;#1-描述&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA集合</title>
    <link href="https://rockspeechcoder.github.io/2020/06/29/java-ji-he/"/>
    <id>https://rockspeechcoder.github.io/2020/06/29/java-ji-he/</id>
    <published>2020-06-29T14:11:06.000Z</published>
    <updated>2022-07-27T17:04:41.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA集合"><a href="#JAVA集合" class="headerlink" title="JAVA集合"></a>JAVA集合</h1><img src="/2020/06/29/java-ji-he/image-1.png" class=""><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>优点：是一种简单的线性序列，可以快速地访问数组元素，效率高。如果从效率和类型检查的角度讲，数组是最好的。</p></li><li><p>缺点：不灵活。容量需要事先定义好，不能随着需求变化扩容。</p></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>数据类型的参数化，数据类型的一个占位符（形式参数）。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>有序，可重复。</p><p>有三个实现类。ArrayList、LinkedList和Vector。</p><ul><li>在末尾添加一个元素：<code>boolean add(E e)</code></li><li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li><li>是否为空：<code>boolean isEmpty()</code></li><li>删除某个元素：<code>boolean remove(Object e)</code></li><li>清空：<code>void clear()</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>获取链表大小（包含元素的个数）：<code>int size()</code></li><li>添加一个list：<code>boolean addAll(Collection c)</code></li><li>删除与另一个list相同元素：<code>boolean removeAll(Collection c)</code></li><li>取交集：<code>boolean retainAll(Collection c)</code></li><li>是否包含另一个list：<code>boolean containsAll(Collection c)</code></li></ul><h3 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h3><p>用数组实现的存储。查询效率高，增删效率低，线程不安全。</p><p>通过数组扩容的方式实现不限制大小。</p><ul><li><p>指定索引添加或替换：<code>boolean set(int index, E e)</code></p></li><li><p>删除指定索引的元素：<code>E remove(int index)</code></p></li><li><p>是否存在某个元素，返回第一次出现的索引：<code>int indexOf(E e)</code></p></li><li><p>是否存在某个元素，返回最后一次出现的索引：<code>int indexOf(E e)</code></p></li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>用双向链表实现的存储。查询效率低，增删效率高，线程不安全。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>用数组实现的存储，效率低，线程安全。相关方法做了同步检查synchronized。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>存储键值对。键不可重复。</p><p>实现类HashMap、TreeMap、HashTable、Properties</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>线程不安全，效率高，允许key或者value为null，</p><ul><li>添加一个键值对：<code>Object put(Object key,Object value)</code></li><li>通过键查找值：<code>Object get(Object key)</code></li><li>是否为空：<code>boolean isEmpty()</code></li><li>删除指定键的键值对：<code>Object remove(Object key)</code></li><li>是否包含键对象：<code>boolean containsKey(Object key)</code></li><li>是否包含值对象：<code>boolean containsValue(Object value)</code></li><li>清空：<code>void clear()</code></li><li>获取Map大小（包含键值对的个数）：<code>int size()</code></li><li>添加一个Map中的所有对象：<code>void putAll(Map m)</code></li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>红黑二叉树的典型实现，排序key。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>线程安全，效率低，不允许key或者value为null。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序，不可重复。</p><ul><li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>无序的，实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>有序的，实现了<code>SortedSet</code>接口。</p><h2 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h2><ul><li>迭代器遍历List</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();for (Iterator&lt;String&gt; it &#x3D; list.iterator(); it.hasNext(); ) &#123;     String s &#x3D; it.next();     System.out.println(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代器遍历Set</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();for (Iterator&lt;String&gt; it &#x3D; set.iterator(); it.hasNext(); ) &#123;     String s &#x3D; it.next();     System.out.println(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代器遍历Map</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();Set &lt;Entry&lt;String,String&gt;&gt; s &#x3D; map.entrySet();for (Iterator&lt;String&gt; it &#x3D; s.iterator(); it.hasNext(); ) &#123;     Entry e &#x3D; it.next();     System.out.println(e.getKey() + e.getValue());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();Set&lt;String&gt; s &#x3D; map.keySet();for(Iterator&lt;String&gt; it &#x3D; s.iterator(); it.hasNext(); )&#123;    String key &#x3D; it.next();    System.out.println(key + map.get(key));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul><li><p><code>void sort(List)</code>：对List元素升序排列</p></li><li><p><code>void shuffle(List)</code>：对List容器内元素随机排列</p></li><li><p><code>void reverse(List)</code>：对List元素逆转排列</p></li><li><p><code>void fill(List,Object)</code>：用一个特定的对象重写List容器</p></li><li><p><code>int binarySearch(List,Object)</code>：顺序折半查找</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA集合&quot;&gt;&lt;a href=&quot;#JAVA集合&quot; class=&quot;headerlink&quot; title=&quot;JAVA集合&quot;&gt;&lt;/a&gt;JAVA集合&lt;/h1&gt;&lt;img src=&quot;/2020/06/29/java-ji-he/image-1.png&quot; class=&quot;&quot;&gt;

</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="https://rockspeechcoder.github.io/2020/06/13/lambda/"/>
    <id>https://rockspeechcoder.github.io/2020/06/13/lambda/</id>
    <published>2020-06-13T11:52:30.000Z</published>
    <updated>2022-08-25T12:03:07.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>格式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">(param1,param2) -&gt; &#123;&#x2F;&#x2F; 重写方法的代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用lambda必须有接口（函数式接口），接口中有且仅有一个抽象方法</li><li>使用lambda必须具有上下文推断</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;p&gt;格式&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-j</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架 - MyBatis</title>
    <link href="https://rockspeechcoder.github.io/2020/05/17/ssm-kuang-jia-mybatis/"/>
    <id>https://rockspeechcoder.github.io/2020/05/17/ssm-kuang-jia-mybatis/</id>
    <published>2020-05-17T15:42:11.000Z</published>
    <updated>2022-08-25T11:53:31.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM框架-MyBatis"><a href="#SSM框架-MyBatis" class="headerlink" title="SSM框架 - MyBatis"></a>SSM框架 - MyBatis</h1><h2 id="1-描述："><a href="#1-描述：" class="headerlink" title="1. 描述："></a>1. 描述：</h2><p>   基于java的持久层框架，包括SQL Maps和Data Access Objects（DAO）</p><h2 id="2-MyBatis特性："><a href="#2-MyBatis特性：" class="headerlink" title="2. MyBatis特性："></a>2. MyBatis特性：</h2><ul><li>支持定制化SQL、存储过程以及高级映射的优秀的持久层框架</li><li>避免了几乎所有的JDBC代码和手动设置参数以及获取结果集</li><li>可以使用简单的XML或注解用于配置和原始映射，将接口和JAVA的pojo映射成数据库中的记录</li><li>半自动的ORM框架</li></ul><h2 id="3-核心配置文件"><a href="#3-核心配置文件" class="headerlink" title="3. 核心配置文件"></a>3. 核心配置文件</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>       <span class="token comment">&lt;!--        MyBatis核心配置文件中，标签的顺序：        properties?,settings?,typeAliases?,typeHandlers?,        objectFactory?,objectWrapperFactory?,reflectorFactory?,        plugins?,environments?,databaseIdProvider?,mappers?    --></span>    <span class="token comment">&lt;!--引入properties文件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc.properties<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment">&lt;!--设置类型别名--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--            typeAlias：设置某个类型的别名            属性：            type：设置需要设置别名的类型            alias：设置某个类型的别名，若不设置该属性，那么该类型拥有默认的别名，即类名            且不区分大小写        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.ssm.mybatis.pojo.User<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAlias</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--以包为单位，将包下所有的类型设置默认的类型别名，即类名且不区分大小写--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.ssm.mybatis.pojo<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">></span></span>              <span class="token comment">&lt;!--    environments：配置多个连接数据库的环境    属性：    default：设置默认使用的环境的id--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--        environment：配置某个具体的环境        属性：        id：表示连接数据库的环境的唯一标识，不能重复    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--            transactionManager：设置事务管理方式            属性：            type="JDBC|MANAGED"            JDBC：表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事            务的提交或回滚需要手动处理            MANAGED：被管理，例如Spring        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment">&lt;!--            dataSource：配置数据源            属性：            type：设置数据源的类型            type="POOLED|UNPOOLED|JNDI"            POOLED：表示使用数据库连接池缓存数据库连接            UNPOOLED：表示不使用数据库连接池            JNDI：表示使用上下文中的数据源        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!--设置连接数据库的驱动--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.driver&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment">&lt;!--设置连接数据库的连接地址--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.url&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment">&lt;!--设置连接数据库的用户名--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.username&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment">&lt;!--设置连接数据库的密码--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.password&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--引入映射文件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mappers/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment">&lt;!--            以包为单位引入映射文件            要求：            1、mapper接口所在的包要和映射文件所在的包一致            2、mapper接口要和映射文件的名字一致        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.learn.mybatis.mapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-MyBatis映射文件"><a href="#4-MyBatis映射文件" class="headerlink" title="4. MyBatis映射文件"></a>4. MyBatis映射文件</h2><ul><li><p>ORM（Object Relationship  Mapping）：对象关系映射</p><ul><li>对象：Java实体类对象</li><li>关系：关系型数据库</li><li>映射：二者对应关系</li></ul></li><li><p>两个一致：</p><ul><li>mapper接口的全类名和映射文件的命名空间（namespace）一致</li><li>mapper接口中方法名和映射文件中编写SQL的标签的id属性一致</li></ul></li></ul><h2 id="5-SqlSessionFactory"><a href="#5-SqlSessionFactory" class="headerlink" title="5. SqlSessionFactory"></a>5. SqlSessionFactory</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取核心配置文件的输入流InputStream r &#x3D;  Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);&#x2F;&#x2F; 获取SqlSessionFactoryBuilder对象SqlSessionFactoryBuilder sqlSessionFactoryBuilder &#x3D; new SqlSessionFactoryBuilder();&#x2F;&#x2F; 获取SqlSessionFactory对象SqlSessionFactory sqlSessionFactory &#x3D;  sqlSessionFactoryBuilder.build(r);&#x2F;&#x2F; 获取sql的会话对象SqlSession(不会自动提交事务)，是MyBatis提供的操作数据库对象SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();&#x2F;&#x2F; 获取sql的会话对象SqlSession(会自动提交事务)，是MyBatis提供的操作数据库对象&#x2F;&#x2F; SqlSession sqlSession &#x3D; sqlSessionFactory.openSession(true);&#x2F;&#x2F; 获取UserMapper的代理实现类对象UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);&#x2F;&#x2F; 调用mapper接口中的方法，实现添加用户信息的功能int result &#x3D; mapper.insertUser();System.out.println(&quot;结果：&quot; + result);&#x2F;&#x2F; 提交事务sqlSession.commit();&#x2F;&#x2F; 关闭SqlSessionsqlSession.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-结果映射"><a href="#6-结果映射" class="headerlink" title="6. 结果映射"></a>6. 结果映射</h2><ul><li>resultType：设置结果类型，即查询的数据要转换的java对象</li><li>resultMap：自定义映射，处理多对一或一对多</li></ul><h2 id="7-获取参数值"><a href="#7-获取参数值" class="headerlink" title="7. 获取参数值"></a>7. 获取参数值</h2><ul><li>${}：本质是字符串拼接。若为字符串类型或日期类型，需要手动加单引号（批量删除时用，in (${ids})）</li><li>#{}：本质是占位符赋值。若为字符串类型或日期类型，自动加单引号。（常用）</li><li>arg0，arg1…param1,param2</li><li>以map集合作为参数，根据key取值</li><li>以实体类作为参数，根据字段名取值</li><li>@Param(“key”)，根据key取值</li><li>@MapKey(“id”)，把查询出的数据放在Map中，以id为键</li></ul><h2 id="8-resultMap"><a href="#8-resultMap" class="headerlink" title="8. resultMap"></a>8. resultMap</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empAndDeptResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp_id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empId<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--多对一的处理--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Dept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptId<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptAndEmpResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Dept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptId<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--一对多的处理--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp_id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empId<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-动态SQL"><a href="#9-动态SQL" class="headerlink" title="9. 动态SQL"></a>9. 动态SQL</h2><ul><li><p>if</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getEmpListByMoreTJ<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from t_emp where 1=1    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ename != <span class="token punctuation">'</span><span class="token punctuation">'</span> and ename != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    and ename = #&#123;ename&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age != <span class="token punctuation">'</span><span class="token punctuation">'</span> and age != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    and age = #&#123;age&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex != <span class="token punctuation">'</span><span class="token punctuation">'</span> and sex != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    and sex = #&#123;sex&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>where</p><p>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字；若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的 and去掉</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getEmpListByMoreTJ2<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from t_emp    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ename != <span class="token punctuation">'</span><span class="token punctuation">'</span> and ename != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            ename = #&#123;ename&#125;        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age != <span class="token punctuation">'</span><span class="token punctuation">'</span> and age != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            and age = #&#123;age&#125;        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex != <span class="token punctuation">'</span><span class="token punctuation">'</span> and sex != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            and sex = #&#123;sex&#125;        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>trim</p><p>trim用于去掉或添加标签中的内容 常用属性： prefix：在trim标签中的内容的前面添加某些内容 prefixOverrides：在trim标签中的内容的前面去掉某些内容 suffix：在trim标签中的内容的后面添加某些内容 suffixOverrides：在trim标签中的内容的后面去掉某些内容</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getEmpListByMoreTJ<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from t_emp    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>trim</span> <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>where<span class="token punctuation">"</span></span> <span class="token attr-name">suffixOverrides</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>and<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ename != <span class="token punctuation">'</span><span class="token punctuation">'</span> and ename != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            ename = #&#123;ename&#125; and        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age != <span class="token punctuation">'</span><span class="token punctuation">'</span> and age != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            age = #&#123;age&#125; and        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex != <span class="token punctuation">'</span><span class="token punctuation">'</span> and sex != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            sex = #&#123;sex&#125;        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>trim</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>choose、when、 otherwise</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getEmpListByChoose<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empColumns<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span> from t_emp    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>choose</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ename != <span class="token punctuation">'</span><span class="token punctuation">'</span> and ename != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            ename = #&#123;ename&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age != <span class="token punctuation">'</span><span class="token punctuation">'</span> and age != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            age = #&#123;age&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex != <span class="token punctuation">'</span><span class="token punctuation">'</span> and sex != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            sex = #&#123;sex&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email != <span class="token punctuation">'</span><span class="token punctuation">'</span> and email != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            email = #&#123;email&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>choose</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>foreach</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertMoreEmp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>insert into t_emp values    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    (null,#&#123;emp.ename&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deleteMoreByArray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    delete from t_emp where    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>eids<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>or<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    eid = #&#123;eid&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deleteMoreByArray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>delete from t_emp where eid in<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>eids<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#&#123;eid&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="10-缓存"><a href="#10-缓存" class="headerlink" title="10. 缓存"></a>10. 缓存</h2><ol><li><p>一级缓存</p><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就 会从缓存中直接获取，不会从数据库重新访问 使一级缓存失效的四种情况： </p><ul><li><p>不同的SqlSession对应不同的一级缓存</p></li><li><p>同一个SqlSession但是查询条件不同</p></li><li><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p></li><li><p>同一个SqlSession两次查询期间手动清空了缓存<code>sqlSession.clearCache()</code></p></li></ul></li><li><p>二级缓存</p><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 二级缓存开启的条件： </p><ul><li>在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置</li><li>在映射文件中设置标签</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口 </li></ul><p>使二级缓存失效的情况： 两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p></li><li><p>缓存配置</p><p>在mapper配置文件中添加的cache标签可以设置一些属性： </p><ul><li>eviction属性：缓存回收策略，默认的是 LRU。 <ul><li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 </li><li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 </li><li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 </li><li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 </li></ul></li><li>flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</li><li>size属性：引用数目，正整数 代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li><li>readOnly属性：只读， true/false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了 很重 要的性能优势。 false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。</li></ul></li><li><p>缓存顺序</p><p>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库。SqlSession关闭之后，一级缓存中的数据会写入二级缓存。</p></li></ol><h2 id="11-分页"><a href="#11-分页" class="headerlink" title="11. 分页"></a>11. 分页</h2><ol><li><p>依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置分页插件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--设置分页插件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span> <span class="token attr-name">interceptor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.github.pagehelper.PageInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用分页插件</p><ol><li><p>在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能 </p><ul><li>pageNum：当前页的页码 </li><li>pageSize：每页显示的条数</li></ul></li><li><p>在查询获取list集合之后，使用PageInfo pageInfo = new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据 </p><ul><li>list：分页之后的数据 </li><li>navigatePages：导航分页的页码数</li></ul></li><li><p>分页相关数据 </p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PageInfo&#123; pageNum&#x3D;8, pageSize&#x3D;4, size&#x3D;2, startRow&#x3D;29, endRow&#x3D;30, total&#x3D;30, pages&#x3D;8, list&#x3D;Page&#123;count&#x3D;true, pageNum&#x3D;8, pageSize&#x3D;4, startRow&#x3D;28, endRow&#x3D;32, total&#x3D;30, pages&#x3D;8, reasonable&#x3D;false, pageSizeZero&#x3D;false&#125;, prePage&#x3D;7, nextPage&#x3D;0, isFirstPage&#x3D;false, isLastPage&#x3D;true, hasPreviousPage&#x3D;true, hasNextPage&#x3D;false, navigatePages&#x3D;5, navigateFirstPage4, navigateLastPage8, navigatepageNums&#x3D;[4, 5, 6, 7, 8] &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>pageNum：当前页的页码 </li><li>pageSize：每页显示的条数</li><li>size：当前页显示的真实条数 </li><li>total：总记录数 </li><li>pages：总页数 </li><li>prePage：上一页的页码 </li><li>nextPage：下一页的页码 </li><li>isFirstPage/isLastPage：是否为第一页/最后一页 </li><li>hasPreviousPage/hasNextPage：是否存在上一页/下一页 </li><li>navigatePages：导航分页的页码数 </li><li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li></ul></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSM框架-MyBatis&quot;&gt;&lt;a href=&quot;#SSM框架-MyBatis&quot; class=&quot;headerlink&quot; title=&quot;SSM框架 - MyBatis&quot;&gt;&lt;/a&gt;SSM框架 - MyBatis&lt;/h1&gt;&lt;h2 id=&quot;1-描述：&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程</title>
    <link href="https://rockspeechcoder.github.io/2020/04/12/java-duo-xian-cheng/"/>
    <id>https://rockspeechcoder.github.io/2020/04/12/java-duo-xian-cheng/</id>
    <published>2020-04-12T04:56:11.000Z</published>
    <updated>2022-07-27T17:04:45.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-多线程"><a href="#JAVA-多线程" class="headerlink" title="JAVA 多线程"></a>JAVA 多线程</h1><h2 id="并发并行"><a href="#并发并行" class="headerlink" title="并发并行"></a>并发并行</h2><ul><li><p>并发：两个或多个事件在同一时间段发生（交替）</p></li><li><p>并行：两个或多个事件在同一时刻发生（同时）</p></li></ul><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>一个程序至少有一个进程，一个进程至少有一个线程。</p><ul><li><p>进程：一个内存中运行的应用程序。每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程。是系统运行程序的基本单位；系统运行一个程序是一个进程从创建、运行到消亡的过程。</p></li><li><p>线程：是进程中的一个执行单元，负责当前进程中的程序的执行。一个进程中至少有一个线程，可以有多个线程。</p></li></ul><p>和多线程相比，多进程的缺点在于：</p><ol><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ol><p>多进程的优点在于：</p><p>​    多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p><p>主线程：执行main方法的线程</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ul><li><p>分时调度</p><p>所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间</p></li><li><p>抢占式调度（JAVA）</p><p>优先让优先级高的线程使用CPU，优先级相同随机选择一个线程</p></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多个现车个互不影响（在不同的栈空间）</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>方式一</p><ol><li>创建一个Thread子类</li><li>在Thread类的子类中重写Thread类中的run方法，设置线程任务</li><li>创建Thread子类的对象</li><li>执行Thread类中的start方法（主线程与新线程）</li></ol></li><li><p>方式二</p><ol><li>创建一个实现Runnable接口的类</li><li>实现run方法</li><li>创建实现类的对象</li><li>创建Thread类对象，构造方法中传递Runnable接口的实现类对象</li><li>执行Thread类中的start方法（主线程与新线程）</li></ol></li></ul><p>方式二避免了单继承的局限性，增强了程序的扩展性，降低了耦合性</p><ul><li><p>匿名内部类实现线程创建</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Thread子类实现new Thread()&#123;    @Override    public void run()&#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;.start();&#x2F;&#x2F; Runnable接口实现new Thread(new Runnable()&#123;    @Override    public void run()&#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取当前线程名称Thread.currentThread().getName(); &#x2F;&#x2F; 获取线程名称Thread t1 &#x3D; new Thread();t1.getName();&#x2F;&#x2F; 设置线程名称t1.setName(&quot;线程1&quot;);&#x2F;&#x2F; 当前线程暂停执行指定的毫秒数Thread.sleep(1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多个线程共享同一数据</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li><p>同步代码块</p><p>线程执行到synchronized会检查是否有锁对象，如果有进入同步中执行，如果没有就阻塞等待。同步执行完归还同步锁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">synchronized(同步锁对象)&#123;&#x2F;&#x2F; 需要同步的代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>同步方法</p><ul><li>方法上添加synchronized，同步锁对象是this</li><li>静态同步方法的锁对象是类.class</li></ul></li><li><p>锁机制（Lock锁）更先进</p><p>在成员位置创建一个ReentrantLock（实现了Lock接口）对象，在出现安全问题的代码前调用lock获取锁，在出现安全问题的代码后调用unlock释放锁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Lock l &#x3D; new Lock();l.lock();&#x2F;&#x2F; 线程安全问题代码l.unlock(); &#x2F;&#x2F; 一般放在try catch后的finally中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li>New：新创建的线程，尚未执行</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；具有CPU的执行资格，等待CPU空闲</li><li>Waiting：运行中的线程，因为某些操作在等待中；通过<code>notify()</code>唤醒</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；放弃CPU的执行资格，CPU空闲也不执行；休眠结束唤醒</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕</li></ul><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><h2 id="线程通信-等待唤醒机制"><a href="#线程通信-等待唤醒机制" class="headerlink" title="线程通信-等待唤醒机制"></a>线程通信-等待唤醒机制</h2><p>等待唤醒机制使各线程有效利用资源，解决线程间处理同一个资源的问题</p><ol><li><p>wait</p><p>线程不再活动参与调度，进入wait set中，这是线程状态是WAITING。等待其他线程执行notify后从wait set中释放出来，重新进入调度队列中</p></li><li><p>notify</p><p>选取所通知对象的wait set中的一个线程释放</p></li><li><p>notifyAll</p><p>释放所通知对象的wait set中的所有线程</p></li></ol><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li><li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li><li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li><li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li><li>已唤醒的线程还需要重新获得锁后才能继续执行。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>使线程可以复用，减少了反复创建和销毁线程的时间</p><p>线程池是一个容器。当程序第一次启动时，创建多个线程保存在集合中。没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p><ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程可管理性</li></ul><p>java.util.concurrent.Executors:线程池的工厂类</p><ul><li><p>创建线程池</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">ExecutorService es &#x3D; Executors.newFixedThreadPool(2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>submit执行线程任务</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">es.submit(new Runnable() &#123;    @Override    public void run() &#123;    System.out.println(Thread.currentThread().getName());    &#125;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>销毁线程池（不建议使用）</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">es.shutdown();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA-多线程&quot;&gt;&lt;a href=&quot;#JAVA-多线程&quot; class=&quot;headerlink&quot; title=&quot;JAVA 多线程&quot;&gt;&lt;/a&gt;JAVA 多线程&lt;/h1&gt;&lt;h2 id=&quot;并发并行&quot;&gt;&lt;a href=&quot;#并发并行&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="https://rockspeechcoder.github.io/2019/09/30/java-servlet/"/>
    <id>https://rockspeechcoder.github.io/2019/09/30/java-servlet/</id>
    <published>2019-09-30T14:02:29.000Z</published>
    <updated>2022-08-25T12:11:05.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="C-S、B-S架构"><a href="#C-S、B-S架构" class="headerlink" title="C/S、B/S架构"></a>C/S、B/S架构</h2><ol><li>Client/Server架构<ul><li>在客户端安装特定软件</li><li>图形显示效果好</li><li>服务器功能升级，需要客户端也同步升级，不利于维护</li></ul></li><li>Browser/Server架构<ul><li>无需安装客户端，浏览器可访问</li><li>功能升级，只需升级服务器端</li><li>图形显示效果一般</li><li>需要通过http协议访问</li></ul></li></ol><h2 id="常见服务器"><a href="#常见服务器" class="headerlink" title="常见服务器"></a>常见服务器</h2><ol><li>Tomcat 免费开源、支持servlet和JSP规范</li><li>jetty 运行效率比Tomcat高</li><li>TODO 后续补充…</li></ol><h2 id="Tomcat目录结构"><a href="#Tomcat目录结构" class="headerlink" title="Tomcat目录结构"></a>Tomcat目录结构</h2><ul><li>bin 存放二进制可执行文件</li><li>conf 存放配置信息</li><li>lib 类库，jar包</li><li>logs 日志文件</li><li>temp 运行时产生的临时数据</li><li>webapps 存放web项目</li><li>work 运行时生成的文件</li></ul><h2 id="Servlet运行测试"><a href="#Servlet运行测试" class="headerlink" title="Servlet运行测试"></a>Servlet运行测试</h2><ol><li><p>概念：</p><p>Server Applet的简称，是服务端的程序，可交互式的处理客户端发送到服务端的请求，并完成操作响应。</p></li><li><p>作用：</p><ul><li>接收客户端请求，完成操作</li><li>动态生成网页</li><li>将包含操作结果的动态网页响应给客户端</li></ul></li><li><p>开发环境：</p><p>lib/servlet-api.jar配置到classpath中</p></li><li><p>实现Servlet的五个方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Tomcat10的servlet-api.jar下包名改成了jakartaimport jakarta.servlet.*;import java.io.IOException;public class MyServlet implements Servlet &#123;    public void init(ServletConfig servletConfig) throws ServletException &#123;    &#125;    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123;    &#125;    public void destroy()&#123;    &#125;    public String getServletInfo()&#123;        return null;    &#125;    public ServletConfig getServletConfig()&#123;        return null;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置web.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--配置Servlet --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>myServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>MyServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--配置Servlet 正整数或0则在servlet加载时执行，值越小优先级越高。未配置或负数则在servlet被请求时再加载--></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-standup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-standup</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 对servlet做映射 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 与servelet的name一致--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>myServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/myservlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重启Tomcat，访问localhost:8080/myWeb/myservlet</p></li></ol><h2 id="IDEA部署Tomcat"><a href="#IDEA部署Tomcat" class="headerlink" title="IDEA部署Tomcat"></a>IDEA部署Tomcat</h2><img src="/2019/09/30/java-servlet/image-1.png" class=""><img src="/2019/09/30/java-servlet/image-2.png" class=""><img src="/2019/09/30/java-servlet/image-3.png" class=""><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ol><li><p>描述：超文本传输协议，给予请求和响应模式的、无状态的、应用层的协议，运行于TCP协议基础之上。</p></li><li><p>特点：</p><ul><li>支持客户端/服务器模式</li><li>简单快速：客户端指向服务器发送请求方法和路径，服务器即可响应数据，通信速度很快</li><li>灵活：http允许传输任意类型的数据，传输的数据类型由Content-type标识</li><li>无连接：每次TCP连接只处理一个或多个请求，服务器处理完请求即断开连接，节省时间。（HTTP1.1会等几秒断开，如果有新连接则暂时不断）</li><li>无状态：HTTP协议是无状态协议，对事务处理没有记忆能力</li><li>HTTP1.1：一个TCP连接上可以传送多个HTTP请求，多个请求和响应可以重叠进行，增加更多的响应头和请求头，Connection报头来控制</li></ul></li><li><p>通信流程：</p><ul><li>客户端与服务器建立连接（三次握手）</li><li>客户端向服务端发送请求</li><li>服务器接收请求，并根据请求返回响应为文件作为应答</li><li>客户端与服务器关闭连接（四次挥手）</li></ul></li><li><p>请求报文组成：</p><ul><li>请求行：请求方法/地址 URI协议/版本</li><li>请求头：request header</li><li>空行</li><li>请求正文</li></ul></li><li><p>响应报文组成：</p><ul><li>状态行</li><li>响应头 response header</li><li>空行</li><li>响应正文</li></ul></li></ol><h2 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h2><ol><li><p>核心接口和类</p><p>除了实现Servlet接口，还可以通过继承GenericServlet或HttpServlet类实现</p></li><li><p>Servlet接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void init(ServletConfig servletConfig);public void service(ServletRequest request, ServletResponse response);public void destroy();public String getServletInfo();public ServletConfig getServletConfig();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>GenericServlet抽象类</p><p>提供了init()和destroy()的简单实现，只需继承后重写service()方法</p></li><li><p>HttpServlet类（推荐）</p><p>与协议有关的实现，继承了GenericServlet。HTTPServlet子类通过service()方法判断请求类型查找子类重写的方法。HTTPServlet子类至少重写一个方法：doGet、doPost、doPut、doDelete</p></li></ol><h2 id="注解（Servlet-3-0后支持）"><a href="#注解（Servlet-3-0后支持）" class="headerlink" title="注解（Servlet 3.0后支持）"></a>注解（Servlet 3.0后支持）</h2><p>@WebServlet(name,value,urlPatterns,loadOnStartup)</p><ul><li>name：同<servlet-name></li><li>value：同<url-pattern>，可配置多个</li><li>urlPatterns：同value，不能同时使用</li><li>loadOnStartup：同<load-on-startup></li></ul><h2 id="Servlet注解"><a href="#Servlet注解" class="headerlink" title="Servlet注解"></a>Servlet注解</h2><ol><li><p>request对象</p><ul><li><p>get明文传递，效率高，数据量小，不安全；post密文传递，数据量大，安全，效率低</p></li><li><p>主要方法</p><ul><li>String getParameter(String name) ：根据表单组件名称获取提交数据</li><li>void setCharacterEncoding(String charset)：指定每个请求的编码</li><li>getRequestDispatcher(“/otherServlet”)：转发跳转</li><li>setAttribute(key,value)：存数据</li><li>getAttribute(key)：取数据</li></ul></li></ul></li><li><p>response对象</p><ul><li><p>主要方法</p><ul><li>setHeader(String name,String value)：设置响应头</li><li>setContentType(String type)：设置响应类型和响应式的编码格式</li><li>setCharacterEncoding(String charset)：设置服务端响应内容的编码格式</li><li>PrintWriter getWriter()：获取字符输出流</li><li>sendRedirect(String targetURI)：页面重定向跳转</li></ul></li><li><p>中文乱码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">res.setCharacterEncoding(&quot;UTF-8&quot;);res.setHeader(&quot;Content-Type&quot;:&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);res.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);&#x2F;&#x2F;推荐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><ul><li>服务器行为，浏览器只做了一次请求，浏览器地址不变</li><li>转发之间传输的信息不会丢失</li><li>只能转发给统一个web应用下的组件</li></ul><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul><li>客户端行为，浏览器做了两次请求，浏览器地址栏改变</li><li>response没有作用域，两次请求的数据无法共享，信息会丢失</li><li>?key=value传递明文数据，getParameter(key)取数据</li><li>可以重定向到任何资源路径</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li><p>实例化</p><ul><li>用户第一次访问servlet时由容器调用Servlet构造器创建具体的对象，也可以在启动时就创建</li><li>只执行一次</li></ul></li><li><p>初始化</p><ul><li><p>初始化阶段，init()方法会被调用</p></li><li><p>只被执行一次</p></li></ul></li><li><p>服务</p><ul><li>客户端发送请求时容器将请求和响应对象转发给servlet，传递给service方法</li><li>根据请求次数执行多次</li></ul></li><li><p>销毁</p><ul><li>Servlet容器停止或重启，销毁Servlet对象，并调用destroy()方法</li><li>执行一次</li></ul></li></ol><h2 id="Servlet特性"><a href="#Servlet特性" class="headerlink" title="Servlet特性"></a>Servlet特性</h2><ol><li><p>线程安全问题</p><p>Tomcat容器可以同时多个线程并发访问同一个Servlet，如果在方法中对成员变量做修改，就会有线程安全的问题</p></li><li><p>保证线程安全</p><ul><li>synchronized：将存在线程安全的问题存放在同步代码块中。效率低不推荐</li><li>实现SingleThreadModel接口，每个线程创建servlet实例，但是效率低已淘汰</li><li>尽可能使用局部变量</li></ul></li></ol><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>客户端状态管理，将状态保存在客户端</p><ol><li><p>描述：web服务器在HTTP响应头中附带给浏览器的一小段数据。浏览器在访问该web服务器时，都应在HTTP请求投中将这个Cookie回传给Web服务器</p></li><li><p>创建：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建cookie对象Cookie cookie &#x3D; new Cookie(&quot;name&quot;, &quot;value&quot;);&#x2F;&#x2F; 设置路径：访问权限cookie.setPath(&quot;&#x2F;webs&quot;);&#x2F;&#x2F; 生命周期 &gt;0：有效期，单位秒；0：浏览器关闭；-1：内存存储cookie.setMaxAge(-1);&#x2F;&#x2F; 响应resp.addCookie(cookie);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取Cookie</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Cookie[] cookies &#x3D; request.getCookies();for(Cookie cookie:cookies)&#123;System.out.println(cookie.getName()+cookie.getValue());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编码解码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 编码URLEncoder.encode(&quot;中文&quot;,&quot;UTF-8&quot;);&#x2F;&#x2F; 解码URLDecoder.decode(cookie.getName(),&quot;UTF-8&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>优缺点：</p><ul><li><p>优点</p><ol><li>可配置到期规则</li><li>简单，键值对</li><li>数据持久性，过期之前一直保存在浏览器上</li></ol></li><li><p>缺点</p><ol><li>大小受限制</li><li>用户可设置浏览器禁用Cookie</li><li>安全风险：有可能被篡改</li></ol></li></ul></li></ol><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ol><li><p>描述：用于记录用户的状态。一段时间内，单个客户端与Web服务器的一连串相关的交互过程</p></li><li><p>原理：</p><ul><li>服务器为每一次会话分配一个Session对象</li><li>同一个浏览器（未关闭）发起的多次请求，同属于一次会话</li><li>首次使用到Session时，服务器会自动创建Session，并创建Cookie存储SessionId发送回客户端</li></ul></li><li><p>Session操作</p><ol><li><p>创建session</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">HttpSession session &#x3D; request.getSession();System.out.println(&quot;ID&quot;+session.getId())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>设置时效</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">session.setmaxInactiveInterval(seconds)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存数据</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">session.setAttribute(&quot;key&quot;,value);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取数据</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">session.getAttribute(&quot;key&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>移除数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">session.removeAttribute(&quot;key&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>退出登录、注销</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">session.invalidate()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p>生命周期</p><ul><li>开始：第一次使用到Session的请求产生，创建session</li><li>结束：浏览器关闭/session超时/手动注销</li></ul></li><li><p>浏览器禁用cookie解决方案-URL重写</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String newURL&#x3D; response.encodeRedirectURL(&quot;&#x2F;要跳转的路径&quot;)response.sendRedirect(newURL)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><ol><li><p>描述：全局对象，对应一个Tomcat中的web应用。Web服务器启动时，会为每一个web应用创建一块共享的存储区域。服务器关闭时销毁。</p></li><li><p>获取：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getServletContext();&#x2F;&#x2F; this&#x2F;request&#x2F;session获取的ServletContext是同一个<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>作用：</p><ol><li><p>获取项目真实路径</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">servletContext.getRealPath(&quot;&#x2F;&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取项目上下文路径（应用程序名称）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">servletContext.getContextPath();request.getContextPath();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>全局作用域的容器</p><ul><li><p>存储数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">servletContext.setAttribute(&quot;key&quot;,value);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">servletContext.getAttribute(&quot;key&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>移除数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">servletContext.removeAttribute(&quot;key&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>特点：</p><ul><li>一个应用对应一个Servlet上下文</li><li>生命周期：只要容器不关闭、应用不卸载，servletContext就一直存在</li></ul></li></ol></li></ol><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ol><li><p>描述：处于客户端与服务器目标资源之间的一道过滤技术。</p></li><li><p>作用：先于Servlet处理客户端请求；响应时根据执行流程再次反向执行Filter。解决多个Servlet共同代码冗余代码。</p></li><li><p>实现：</p><ul><li>编写Java类实现Filter接口</li><li>在doFilter方法里设计拦截逻辑</li><li>设置拦截路径</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebFilter(&quot;&#x2F;filter&quot;)public class MyFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;Request Filter&quot;);        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;Response Filter&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>web.xml配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>com.learn.myservlet.learnservlet.MyServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/目标资源路径<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>过滤器链</p><ol><li>描述：一个web应用中可以编写多个Filter，一组Filter组合称为Filter链</li><li>优先级：<ul><li>如果为注解，按照泪泉名称的字符串顺序决定执行顺序</li><li>如果为web.xml，按照filter-mapping注册顺序，从上到下</li><li>web.xml配置优先注解</li><li>如果注解和web.xml同时配置，会创建多个过滤器对象，造成多次过滤</li></ul></li></ol></li><li><p>拦截路径</p><ul><li>精确拦截，/test</li><li>后缀拦截，*.jsp</li><li>通配符拦截，/*</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h1&gt;&lt;h2 id=&quot;C-S、B-S架构&quot;&gt;&lt;a href=&quot;#C-S、B-S架构&quot; class=&quot;header</summary>
      
    
    
    
    <category term="编程" scheme="https://rockspeechcoder.github.io/categories/program/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat启动乱码</title>
    <link href="https://rockspeechcoder.github.io/2019/09/28/wen-ti-ji-lu-tomcat-qi-dong-luan-ma/"/>
    <id>https://rockspeechcoder.github.io/2019/09/28/wen-ti-ji-lu-tomcat-qi-dong-luan-ma/</id>
    <published>2019-09-28T15:06:56.000Z</published>
    <updated>2022-08-25T12:10:57.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat启动乱码"><a href="#Tomcat启动乱码" class="headerlink" title="Tomcat启动乱码"></a>Tomcat启动乱码</h1><p>修改tomcat的conf下的logging.properties中的参数，</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">java.util.logging.ConsoleHandler.encoding &#x3D; GBK<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tomcat启动乱码&quot;&gt;&lt;a href=&quot;#Tomcat启动乱码&quot; class=&quot;headerlink&quot; title=&quot;Tomcat启动乱码&quot;&gt;&lt;/a&gt;Tomcat启动乱码&lt;/h1&gt;&lt;p&gt;修改tomcat的conf下的logging.properties中的参数，</summary>
      
    
    
    
    <category term="问题记录" scheme="https://rockspeechcoder.github.io/categories/bugfix/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Servlet找不到包</title>
    <link href="https://rockspeechcoder.github.io/2019/09/26/wen-ti-ji-lu-servlet-zhao-bu-dao-bao/"/>
    <id>https://rockspeechcoder.github.io/2019/09/26/wen-ti-ji-lu-servlet-zhao-bu-dao-bao/</id>
    <published>2019-09-26T14:15:54.000Z</published>
    <updated>2022-08-25T12:10:52.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet找不到包"><a href="#Servlet找不到包" class="headerlink" title="Servlet找不到包"></a>Servlet找不到包</h1><p>实现Servlet方法后javac时找不到<code>javax.Servlet</code>，查阅后发现在Tomcat 10版本中<code>Jakarta.servlet</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Servlet找不到包&quot;&gt;&lt;a href=&quot;#Servlet找不到包&quot; class=&quot;headerlink&quot; title=&quot;Servlet找不到包&quot;&gt;&lt;/a&gt;Servlet找不到包&lt;/h1&gt;&lt;p&gt;实现Servlet方法后javac时找不到&lt;code&gt;javax.S</summary>
      
    
    
    
    <category term="问题记录" scheme="https://rockspeechcoder.github.io/categories/bugfix/"/>
    
    
    <category term="JAVA" scheme="https://rockspeechcoder.github.io/tags/java/"/>
    
  </entry>
  
</feed>
